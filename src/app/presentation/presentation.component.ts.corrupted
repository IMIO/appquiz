
import { Component, ChangeDetectorRef, OnInit, OnDestroy } from '@angular/core';
import { TimerService, TimerState } from '../services/timer.service';
import { CommonModule } from '@angular/common';
import { QuizService, QuizStep } from '../services/quiz-secure.service';
import { Question } from '../models/question.model';
import { User } from '../models/user.model';
import { Observable, timer, Subscription, firstValueFrom } from 'rxjs';
import { LeaderboardCacheService } from '../services/leaderboard-cache.service';
import { LeaderboardEntry } from '../models/leaderboard-entry.model';
import { trigger, state, style, transition, animate, query, stagger } from '@angular/animations';
import html2canvas from 'html2canvas';
import { QRCodeComponent } from 'angularx-qrcode';
import { AdminAuthService } from '../services/admin-auth.service';
import { Router } from '@angular/router';
import { WebSocketTimerService } from '../services/websocket-timer.service';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { UserStateService } from '../services/user-state.service';

@Component({
  selector: 'app-presentation',
  standalone: true,
  imports: [CommonModule, QRCodeComponent],
  templateUrl: './presentation.component.html',
  styleUrls: ['./presentation.component.css'],
  animations: [
    // Animation pour les transitions d'√©tapes
    trigger('stepTransition', [
      transition(':enter', [
        style({ opacity: 0, transform: 'translateY(30px)' }),
        animate('500ms cubic-bezier(0.4, 0, 0.2, 1)',
          style({ opacity: 1, transform: 'translateY(0)' }))
      ])
    ]),

    // Animation pour les √©l√©ments de liste
    trigger('listAnimation', [
      transition('* => *', [
        query(':enter', [
          style({ opacity: 0, transform: 'translateY(20px)' }),
          stagger(100, [
            animate('400ms cubic-bezier(0.4, 0, 0.2, 1)',
              style({ opacity: 1, transform: 'translateY(0)' }))
          ])
        ], { optional: true })
      ])
    ]),

    // Animation pour les images
    trigger('imageAnimation', [
      transition(':enter', [
        style({ opacity: 0, transform: 'scale(0.9)' }),
        animate('400ms cubic-bezier(0.4, 0, 0.2, 1)',
          style({ opacity: 1, transform: 'scale(1)' }))
      ])
    ])
  ]
})
export class PresentationComponent implements OnInit, OnDestroy {
  getImageUrl(url: string | undefined): string {
    if (!url) return '';
    if (url.startsWith('http')) return url;
    // Si c'est un asset statique (dans /assets ou favicon), retourner l'URL telle quelle
    if (url.startsWith('/assets') || url.startsWith('assets') || url.startsWith('/favicon.ico')) {
      return url;
    }
    // Sinon, pr√©fixer par l'API (pour images upload√©es/dynamiques)
    const apiBase = this.apiUrl.replace(/\/api$/, '');
    return `${apiBase}${url}`;
  }
  step: any = 'lobby'; // Typage √©largi pour compatibilit√© template Angular
  showRestoreDialog: boolean = false;
  private minModalDisplayTime = 2000; // Afficher le modal au minimum 2 secondes
  private modalStartTime = 0;
  buttonsEnabled = false;

  async ngOnInit() {
    console.log('[PRESENTATION] Initialisation du composant de pr√©sentation...');
    
    // AM√âLIORATION: Syst√®me de rafra√Æchissement plus agressif et plus fiable pour le leaderboard
    const refreshIntervals = {
      result: 1500,   // Rafra√Æchissement plus fr√©quent pendant l'√©tape r√©sultat (1.5 secondes)
      end: 2500,      // Rafra√Æchissement plus fr√©quent pendant l'√©tape finale (2.5 secondes)
      question: 5000  // Rafra√Æchissement plus fr√©quent pendant l'√©tape question (5 secondes)
    };
    
    // CORRECTION: S'abonner aux messages de reset du quiz
    const quizResetSub = this.websocketTimerService.getQuizResets().subscribe(resetData => {
      console.log('[PRESENTATION] Message de reset du quiz re√ßu via WebSocket:', resetData);
      
      if (resetData.action === 'reset-all') {
        // Nettoyer imm√©diatement les listes locales
        this.participants = [];
        this.voters = [];
        this.leaderboard = [];
        this.answersCount = [];
        
        // Nettoyer les caches
        this.leaderboardCacheService.clearAllCaches();
        
        // Forcer une mise √† jour de l'interface
        this.cdr.detectChanges();
        
        console.log('[PRESENTATION] Nettoyage complet suite au message de reset');
      }
    });
    this.subscriptions.push(quizResetSub);
    
    // CORRECTION: S'abonner aux mises √† jour de score via WebSocket
    const userScoreSub = this.websocketTimerService.getUserScores().subscribe(scoreData => {
      console.log('[PRESENTATION] Score utilisateur re√ßu via WebSocket:', scoreData);
      
      // Mettre √† jour le cache du leaderboard avec le nouveau score
      if (scoreData.userId && scoreData.score > 0) {
        const leaderboardEntry = {
          id: scoreData.userId,
          name: scoreData.userName || 'Anonyme',
          score: scoreData.score,
          avatarUrl: scoreData.avatarUrl,
          currentQuestionCorrect: scoreData.questionIndex === this.currentIndex,
          totalTime: 0 // Valeur par d√©faut pour la propri√©t√© totalTime requise
        };
        
        // CORRECTION MAJEURE: Mettre √† jour directement le leaderboard existant
        const existingEntryIndex = this.leaderboard.findIndex(entry => entry.id === scoreData.userId);
        if (existingEntryIndex >= 0) {
          // Mettre √† jour le score seulement s'il est sup√©rieur au score existant
          if (scoreData.score > (this.leaderboard[existingEntryIndex].score || 0)) {
            console.log(`[PRESENTATION] Mise √† jour du score existant pour ${scoreData.userName}: ${this.leaderboard[existingEntryIndex].score} -> ${scoreData.score}`);
            this.leaderboard[existingEntryIndex].score = scoreData.score;
            this.leaderboard[existingEntryIndex].currentQuestionCorrect = scoreData.questionIndex === this.currentIndex;
          }
        } else {
          // Ajouter une nouvelle entr√©e
          console.log(`[PRESENTATION] Ajout d'un nouveau joueur au leaderboard: ${scoreData.userName} avec score ${scoreData.score}`);
          this.leaderboard.push(leaderboardEntry);
        }
        
        // Trier le leaderboard
        this.leaderboard.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.totalTime - b.totalTime;
        });
        
        // Mettre √† jour le cache local
        this.leaderboardCacheService.updateCache([leaderboardEntry]);
        
        // Mettre √©galement √† jour le cache local des scores pour une r√©cup√©ration rapide
        this.scoreCache[scoreData.userId] = {
          score: scoreData.score,
          timestamp: Date.now()
        };
        
        // Mettre √† jour le lastSuccessfulLeaderboard pour √©viter les r√©gressions
        this.lastSuccessfulLeaderboard = [...this.leaderboard];
        
        // Forcer la d√©tection de changements pour mettre √† jour l'UI imm√©diatement
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(userScoreSub);
    
    // Premier rafra√Æchissement imm√©diat
    setTimeout(() => {
      // Rafra√Æchissement initial des scores
      this.forceLeaderboardUpdate('rafra√Æchissement initial');
    }, 500);
    
    // Configurer le rafra√Æchissement p√©riodique avec intervalle adaptatif
    setInterval(() => {
      // D√©terminer l'intervalle et la priorit√© en fonction de l'√©tape actuelle
      if (this.step === 'result') {
        // Rafra√Æchissement p√©riodique des scores pour l'√©tape r√©sultat
        this.forceLeaderboardUpdate('rafra√Æchissement p√©riodique - r√©sultat');
        
        // Programmation d'une deuxi√®me mise √† jour diff√©r√©e pour s'assurer que les changements sont pris en compte
        setTimeout(() => {
          this.forceLeaderboardUpdate('rafra√Æchissement secondaire - r√©sultat');
        }, 700);
      } else if (this.step === 'end') {
        // Rafra√Æchissement p√©riodique des scores pour l'√©tape finale
        this.forceLeaderboardUpdate('rafra√Æchissement p√©riodique - fin');
      } else if (this.step === 'question') {
        // Rafra√Æchissement des scores pendant l'√©tape question
        this.forceLeaderboardUpdate('rafra√Æchissement p√©riodique - question');
      }
    }, 2000); // Intervalle de base r√©duit √† 2 secondes pour plus de r√©activit√©
    
    // CORRECTION FINALE: S'abonner aux mises √† jour du cache
    const cacheSubscription = this.leaderboardCacheService.lastSuccessfulLeaderboard$.subscribe(cachedLeaderboard => {
      if (cachedLeaderboard.length > 0 && this.step === 'result' && 
          (!this.leaderboard.length || !this.leaderboard.some(entry => entry.score > 0))) {
        // R√©ception et traitement des donn√©es cach√©es
        this.leaderboard = JSON.parse(JSON.stringify(cachedLeaderboard));
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(cacheSubscription);
    
    // Configuration du traitement des erreurs non g√©r√©es pour le diagnostic
    window.addEventListener('error', (event) => {
      console.error('[PRESENTATION][ERROR-HANDLER] Erreur non g√©r√©e:', event.error);
    });
    
    // √âTAPE 1: Restauration imm√©diate depuis le cache local pour √©viter l'√©cran vide
    try {
      console.log('[PRESENTATION] √âTAPE 1: Restauration initiale du cache...');
      const cachedParticipantsStr = localStorage.getItem('presentation_participants_cache');
      const cachedLeaderboardStr = localStorage.getItem('leaderboard_cache');
      
      // CORRECTION FINALE: Restaurer √©galement le cache du leaderboard
      if (cachedLeaderboardStr) {
        try {
          const parsedLeaderboard = JSON.parse(cachedLeaderboardStr);
          if (Array.isArray(parsedLeaderboard) && parsedLeaderboard.length > 0) {
            // Restauration des entr√©es depuis le cache local
            this.lastSuccessfulLeaderboard = parsedLeaderboard;
            
            // Reconstruire le cache des scores √† partir du leaderboard restaur√©
            parsedLeaderboard.forEach(entry => {
              if (entry.score > 0) {
                this.scoreCache[entry.id] = {
                  score: entry.score,
                  timestamp: Date.now() // Utiliser l'horodatage actuel
                };
              }
            });
          }
        } catch (error) {
          // Gestion silencieuse des erreurs de cache
        }
      }
      
      if (cachedParticipantsStr) {
        try {
          const parsedParticipants = JSON.parse(cachedParticipantsStr);
          if (Array.isArray(parsedParticipants) && parsedParticipants.length > 0) {
            console.log(`[PRESENTATION] ${parsedParticipants.length} participants restaur√©s depuis le cache local au d√©marrage`);
            this.participants = [...parsedParticipants]; // Copie profonde pour √©viter les r√©f√©rences
            // Forcer la mise √† jour imm√©diate de l'UI
            this.cdr.detectChanges();
            
            // Marquer une variable pour indiquer que nous avons d√©j√† des participants du cache
            this.cachedParticipantsLoaded = true;
          }
        } catch (parseError) {
          console.warn('[PRESENTATION] Erreur lors du parsing du cache initial des participants:', parseError);
        }
      } else {
        console.log('[PRESENTATION] Aucun cache de participants disponible au d√©marrage');
      }
    } catch (cacheError) {
      console.warn('[PRESENTATION] Erreur lors de la lecture du cache initial des participants:', cacheError);
    }
    
    // √âTAPE 2: Synchronisation avec l'√©tat du serveur
    try {
      console.log('[PRESENTATION] √âTAPE 2: R√©cup√©ration de l\'√©tat du serveur...');
      const serverState = await this.quizService.getGameState();
      console.log('[PRESENTATION] √âtat du serveur r√©cup√©r√©:', serverState);
      
      // √âTAPE 3: Synchronisation compl√®te
      console.log('[PRESENTATION] √âTAPE 3: Synchronisation compl√®te...');
      await this.synchronizeWithServer(serverState || { step: 'lobby' });
      
      // √âTAPE 4: V√©rification de l'√©tat sauvegard√©
      if ((!serverState || serverState.step === 'lobby') && this.quizService.canRestoreGameState()) {
        console.log('[PRESENTATION] √âtat sauvegard√© disponible, affichage du dialogue de restauration');
        this.showRestoreDialog = true;
        this.modalStartTime = Date.now();
        this.buttonsEnabled = false;
        setTimeout(() => {
          this.buttonsEnabled = true;
        }, this.minModalDisplayTime);
      }
      
      // √âTAPE 5: V√©rification finale des participants
      console.log('[PRESENTATION] √âTAPE 5: V√©rification finale des participants...');
      if (this.participants.length === 0) {
        console.warn('[PRESENTATION] Apr√®s initialisation, la liste des participants est toujours vide');
        
        // Dernier essai de r√©cup√©ration des participants
        try {
          console.log('[PRESENTATION] Tentative finale de r√©cup√©ration des participants...');
          const finalAttemptParticipants = await this.quizService.fetchParticipantsFromServer();
          
          if (finalAttemptParticipants && Array.isArray(finalAttemptParticipants) && finalAttemptParticipants.length > 0) {
            console.log(`[PRESENTATION] ${finalAttemptParticipants.length} participants r√©cup√©r√©s lors de la v√©rification finale`);
            this.participants = finalAttemptParticipants;
            this.cdr.detectChanges();
            
            // Mise √† jour du cache
            try {
              localStorage.setItem('presentation_participants_cache', JSON.stringify(finalAttemptParticipants));
            } catch (cacheError) {
              console.warn('[PRESENTATION] Erreur lors de la mise √† jour du cache final:', cacheError);
            }
          } else {
            console.warn('[PRESENTATION] La v√©rification finale n\'a retourn√© aucun participant');
          }
        } catch (finalError) {
          console.warn('[PRESENTATION] Erreur lors de la v√©rification finale des participants:', finalError);
        }
      }
      
      // Forcer une mise √† jour finale de l'interface
      this.cdr.detectChanges();
      
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors de l\'initialisation:', error);
      
      // En cas d'erreur, essayer une approche de secours
      try {
        console.log('[PRESENTATION] Tentative de r√©cup√©ration de secours...');
        const fallbackState = await this.quizService.getGameState();
        await this.synchronizeWithServer(fallbackState || { step: 'lobby' });
      } catch (innerError) {
        console.error('[PRESENTATION] Erreur de fallback:', innerError);
        
        // En dernier recours, initialiser les souscriptions et restaurer depuis le cache
        console.log('[PRESENTATION] Dernier recours: initialisation des souscriptions et restauration du cache');
        this.initializeSubscriptions(true);
        this.restoreParticipantsFromCache();
      }
    }
    
    // D√©marrer un intervalle pour surveiller la pr√©sence de participants
    this.startParticipantsWatchdog();
  }
  
  // Propri√©t√© pour suivre l'√©tat de chargement du cache
  private cachedParticipantsLoaded = false;
  
  // M√©thode pour surveiller la pr√©sence de participants
  private participantsWatchdogInterval: any;
  
  private startParticipantsWatchdog() {
    // Nettoyer l'intervalle existant si n√©cessaire
    if (this.participantsWatchdogInterval) {
      clearInterval(this.participantsWatchdogInterval);
    }
    
    // Cr√©er un nouvel intervalle qui v√©rifie p√©riodiquement la pr√©sence de participants
    this.participantsWatchdogInterval = setInterval(() => {
      // Ne v√©rifier que si nous sommes en phase lobby ou waiting
      if ((this.step === 'lobby' || this.step === 'waiting') && this.participants.length === 0) {
        console.log('[PRESENTATION][WATCHDOG] Aucun participant d√©tect√©, tentative de r√©cup√©ration...');
        // Tenter de r√©cup√©rer les participants sans perturber l'exp√©rience utilisateur
        this.refreshParticipants().catch(error => {
          console.warn('[PRESENTATION][WATCHDOG] Erreur lors de la r√©cup√©ration des participants:', error);
        });
      }
    }, 15000); // V√©rifier toutes les 15 secondes
  }

  private async initializeNewGame() {
    console.log('[PRESENTATION] Initialisation d\'une nouvelle partie (uniquement si confirm√© par l\'utilisateur)');
    
    // Initialiser les questions localement sans modifier l'√©tat du serveur
    await this.quizService.initQuestions();
    
    try {
      // V√©rifier l'√©tat actuel du serveur
      const currentState = await this.quizService.getGameState();
      
      // Ne modifier l'√©tat serveur que si c'est une nouvelle partie explicitement demand√©e
      // ou si aucun √©tat n'existe sur le serveur
      if (!currentState || !currentState.step) {
        console.log('[PRESENTATION] Aucun √©tat existant sur le serveur, cr√©ation d\'un nouvel √©tat');
        this.step = 'lobby';
        await this.quizService.setStep('lobby');
        this.quizService.initGameState();
      } else {
        console.log('[PRESENTATION] √âtat existant sur le serveur, synchronisation sans modification');
        this.step = currentState.step;
      }
      
      // R√©cup√©rer les participants sans r√©initialiser
      await this.quizService.fetchParticipantsFromServer();
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors de l\'initialisation d\'une nouvelle partie:', error);
    }
    
    // Initialiser les souscriptions
    this.initializeSubscriptions();
  }

  // M√©thode pour synchroniser avec les modifications c√¥t√© gestion
  async synchronizeWithManagement(): Promise<void> {
    console.log('[PRESENTATION] Synchronisation avec les modifications c√¥t√© gestion...');

    // D√©marrer l'√©tat de synchronisation
    this.isSynchronizing = true;
    this.synchronizationSuccess = false;
    this.synchronizationMessage = 'Synchronisation en cours...';

    try {
      // √âtape 1: Synchroniser les questions et reset les donn√©es
      this.synchronizationMessage = 'Rechargement des questions...';
      await this.quizService.synchronizeAfterChanges();

      // √âtape 2: D√©clencher la synchronisation c√¥t√© joueur via WebSocket
      this.synchronizationMessage = 'Notification des joueurs...';
      await this.triggerPlayerQuestionsSync();

      // √âtape 3: R√©initialiser l'√©tat local
      this.synchronizationMessage = 'R√©initialisation de l\'√©tat local...';
      await new Promise(resolve => setTimeout(resolve, 500)); // D√©lai pour l'UX

      this.currentIndex = 0;
      this.currentQuestion = this.quizService.getCurrentQuestion(0);
      this.leaderboard = [];
      this.questionStartTimes = {};
      this.goodAnswersTimesByUser = {};

      // √âtape 4: Retourner au lobby
      this.synchronizationMessage = 'Retour au lobby...';
      this.step = 'lobby';
      this.quizService.setStep('lobby');

      // Succ√®s
      this.synchronizationMessage = '‚úÖ Synchronisation termin√©e avec succ√®s !';
      this.synchronizationSuccess = true;

      console.log('[PRESENTATION] Synchronisation termin√©e, retour au lobby');

      // Masquer le message de succ√®s apr√®s 3 secondes
      setTimeout(() => {
        this.isSynchronizing = false;
        this.synchronizationMessage = '';
        this.synchronizationSuccess = false;
      }, 3000);

    } catch (error) {
      console.error('[PRESENTATION] Erreur lors de la synchronisation:', error);

      // Affichage d'erreur
      this.synchronizationMessage = '‚ùå Erreur lors de la synchronisation';
      this.synchronizationSuccess = false;

      // Masquer le message d'erreur apr√®s 5 secondes
      setTimeout(() => {
        this.isSynchronizing = false;
        this.synchronizationMessage = '';
      }, 5000);
    }
  }

  // M√©thode pour d√©clencher la synchronisation des questions c√¥t√© joueur
  private async triggerPlayerQuestionsSync(): Promise<void> {
    try {
      console.log('[PRESENTATION] D√©clenchement sync questions via WebSocket...');
      console.log('[PRESENTATION] URL appel√©e:', `${this.apiUrl}/quiz/sync-questions`);

      const response = await firstValueFrom(
        this.http.post<any>(`${this.apiUrl}/quiz/sync-questions`, {})
      );

      console.log('[PRESENTATION] R√©ponse serveur sync questions:', response);

      if (response?.success) {
        console.log('[PRESENTATION] Sync questions WebSocket d√©clench√©e avec succ√®s');
      } else {
        console.warn('[PRESENTATION] R√©ponse inattendue du serveur pour sync questions:', response);
      }

    } catch (error) {
      console.error('[PRESENTATION] Erreur lors du d√©clenchement sync questions:', error);
      // Ne pas faire √©chouer toute la synchronisation pour cette erreur
    }
  }

  // M√©thode pour nettoyer toutes les ressources (appel√©e √† la fois dans ngOnDestroy et dans restartGame)
  private cleanupResources(saveParticipants: boolean = true) {
    console.log('[PRESENTATION] Nettoyage des ressources...');
    
    // Nettoyage des souscriptions pour √©viter les fuites m√©moire
    if (this.subscriptions && this.subscriptions.length > 0) {
      console.log(`[PRESENTATION] Nettoyage de ${this.subscriptions.length} souscriptions principales`);
      this.subscriptions.forEach(sub => {
        if (sub && typeof sub.unsubscribe === 'function') {
          sub.unsubscribe();
        }
      });
      this.subscriptions = [];
    }

    // Nettoyage des autres souscriptions
    if (this.answersCountSub) {
      this.answersCountSub.unsubscribe();
      this.answersCountSub = undefined;
      console.log('[PRESENTATION] Nettoyage de answersCountSub');
    }
    
    if (this.timerSub) {
      this.timerSub.unsubscribe();
      this.timerSub = undefined;
      console.log('[PRESENTATION] Nettoyage de timerSub');
    }

    // Nettoyage de l'intervalle de diagnostic
    if (this.diagnosticInterval) {
      clearInterval(this.diagnosticInterval);
      this.diagnosticInterval = undefined;
      console.log('[PRESENTATION] Nettoyage de diagnosticInterval');
    }
    
    // Nettoyage de l'intervalle de rafra√Æchissement des participants
    if (this.lobbyRefreshInterval) {
      clearInterval(this.lobbyRefreshInterval);
      this.lobbyRefreshInterval = undefined;
      console.log('[PRESENTATION] Nettoyage de lobbyRefreshInterval');
    }
    
    // Nettoyage du watchdog des participants
    if (this.participantsWatchdogInterval) {
      clearInterval(this.participantsWatchdogInterval);
      this.participantsWatchdogInterval = undefined;
      console.log('[PRESENTATION] Nettoyage de participantsWatchdogInterval');
    }
    
    // Nettoyage de l'intervalle de rafra√Æchissement du leaderboard
    if (this.leaderboardRefreshInterval) {
      clearInterval(this.leaderboardRefreshInterval);
      this.leaderboardRefreshInterval = undefined;
      console.log('[PRESENTATION] Nettoyage de leaderboardRefreshInterval');
    }
    
    // Nettoyage de la connexion WebSocket si possible
    try {
      if (this.websocketTimerService) {
        // Utiliser disconnect() puis forcer une reconnexion implicite lors du prochain acc√®s
        this.websocketTimerService.disconnect();
        console.log('[PRESENTATION] D√©connexion WebSocket forc√©e');
      }
    } catch (wsError) {
      console.warn('[PRESENTATION] Erreur lors de la d√©connexion WebSocket:', wsError);
    }
    
    // Sauvegarde de la liste des participants avant destruction, si demand√©
    if (saveParticipants) {
      try {
        if (this.participants && this.participants.length > 0) {
          console.log(`[PRESENTATION] Sauvegarde de ${this.participants.length} participants dans le cache avant destruction`);
          localStorage.setItem('presentation_participants_cache', JSON.stringify(this.participants));
        }
      } catch (error) {
        console.warn('[PRESENTATION] Erreur lors de la sauvegarde du cache avant destruction:', error);
      }
    }
    
    // Nettoyage de la cam√©ra si active
    this.stopCamera();
    
    console.log('[PRESENTATION] Nettoyage des ressources termin√©');
  }

  ngOnDestroy() {
    console.log('[PRESENTATION] Destruction du composant...');
    // Utiliser la m√©thode commune de nettoyage des ressources
    this.cleanupResources(true);
    console.log('[PRESENTATION] Nettoyage du composant termin√©');
  }
  participants: User[] = [];
  currentIndex: number = 0;
  currentQuestion: Question | null = null;
  answersCount: number[] = [];
  answersCountSub?: Subscription;
  leaderboard: LeaderboardEntry[] = [];
  // Pour le d√©partage par vitesse de r√©ponse
  questionStartTimes: { [key: string]: number } = {};
  // Stocke le temps de chaque bonne r√©ponse par participant (cl√©: userId, valeur: tableau des temps)
  goodAnswersTimesByUser: { [userId: string]: number[] } = {};
  
  // M√©thode pour obtenir le nombre total de questions
  public getTotalQuestions(): number {
    return this.quizService.getQuestions().length || 3; // Fallback √† 3 questions si vide
  }
  
  // M√©thode pour obtenir le score d'un utilisateur (avec v√©rification suppl√©mentaire)
  public getUserScore(user: LeaderboardEntry): number {
    // R√©cup√©rer le score du leaderboard
    const leaderboardScore = user.score || 0;
    
    // R√©cup√©rer le score du cache pour comparaison
    const cachedScore = this.leaderboardCacheService.getCachedScore(user.id);
    
    // Retourner le score le plus √©lev√© entre les deux sources
    const finalScore = Math.max(leaderboardScore, cachedScore);
    
    // Log pour d√©bogage
    if (leaderboardScore !== cachedScore) {
      console.log(`[SCORE] Diff√©rence de score pour ${user.name}: leaderboard=${leaderboardScore}, cache=${cachedScore}, final=${finalScore}`);
    }
    
    return finalScore;
  }
  
  // M√©thode pour forcer le rafra√Æchissement du leaderboard
  public forceRefreshLeaderboard(): void {
    // Forcer la mise √† jour du leaderboard et invalider les caches
    this.leaderboard = [];
    this.scoreCache = {};
    // Forcer le rechargement des donn√©es en cache
    const cachedLeaderboard = this.leaderboardCacheService.getCachedLeaderboard();
    if (cachedLeaderboard && cachedLeaderboard.length > 0) {
      // Rafra√Æchir d'abord avec le cache puis avec les donn√©es en direct
      this.leaderboard = [...cachedLeaderboard];
      this.cdr.detectChanges();
    }
    // Appeler updateLeaderboard avec un court d√©lai pour √©viter les collisions
    setTimeout(() => this.updateLeaderboard(), 100);
  }

  // Gestion des souscriptions pour √©viter les fuites m√©moire
  private subscriptions: Subscription[] = [];

  // Syst√®me de loading pour synchroniser avec les joueurs
  isLoading: boolean = false;
  loadingMessage: string = '';
  loadingType: string = '';

  // Flag pour √©viter les logs excessifs
  private debugMode = false;

  // R√©f√©rence pour l'intervalle de diagnostic
  private diagnosticInterval?: any;

  // Gestion des images pour √©viter le flash
  imageLoaded: boolean = false;
  resultImageLoaded: boolean = false;
  // Flag pour forcer la disparition imm√©diate des images
  hideImages: boolean = false;

  // Retourne le temps total des bonnes r√©ponses pour un user
  // (m√©thode unique, suppression du doublon)
  windowLocation = window.location.origin;
  timerValue: number = 20;
  timerMax: number = 20; // Dur√©e du timer en secondes, synchronis√©e avec timerValue
  timerActive: boolean = false; // √âtat d'activation du timer pour l'affichage visuel

  // Contr√¥le manuel du timer
  timerStartedManually: boolean = false;

  // Propri√©t√©s pour le cache du leaderboard
  lastSuccessfulLeaderboard: LeaderboardEntry[] = [];
  scoreCache: { [userId: string]: {score: number, timestamp: number} } = {};

  // √âtat de synchronisation des questions
  isSynchronizing: boolean = false;
  synchronizationMessage: string = '';
  synchronizationSuccess: boolean = false;

  // Propri√©t√©s pour la photo de groupe
  cameraStream: MediaStream | null = null;
  cameraActive: boolean = false;
  cameraReady: boolean = false;
  showCameraModal: boolean = false;
  photoTaken: boolean = false;
  timerSub?: Subscription;
  totalAnswers: number = 0;
  totalGood: number = 0;
  totalBad: number = 0;
  voters: {id: any, name: any}[] = [];
  
  // Intervalle de rafra√Æchissement p√©riodique du leaderboard
  private leaderboardRefreshInterval?: any;

  // Affichage temps format√© (mm:ss si > 60s, sinon ss.s)
  public formatTime(ms: number): string {
    if (!ms || ms < 0) return '';
    const totalSeconds = Math.floor(ms / 1000);
    if (totalSeconds < 60) {
      return (ms / 1000).toFixed(2) + ' s';
    } else {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      // Affichage sans centi√®mes pour plus de lisibilit√©
      return `${minutes} min ${seconds.toString().padStart(2, '0')} s`;
    }
  }

  canShowEndButton(): boolean {
    return this.currentIndex === (this.quizService.getQuestions().length - 1) && this.step !== 'end';
  }

  get totalQuestions(): number {
    return this.quizService.getQuestions().length;
  }

  get currentQuestionNumber(): string {
    const questionNum = (this.currentIndex + 1).toString().padStart(2, '0');
    const totalQuestions = this.totalQuestions.toString().padStart(2, '0');
    return `${questionNum} sur ${totalQuestions}`;
  }

  private readonly apiUrl = environment.apiUrl;

  constructor(
    public quizService: QuizService,
    private timerService: TimerService,
    private cdr: ChangeDetectorRef,
    public adminAuthService: AdminAuthService,
    private router: Router,
    private websocketTimerService: WebSocketTimerService,
    private http: HttpClient,
    private userStateService: UserStateService,
    private leaderboardCacheService: LeaderboardCacheService
  ) {
    // Initialiser les souscriptions imm√©diatement pour assurer la synchronisation
    this.initializeSubscriptions();
  }

  private initializeSubscriptions(force: boolean = false) {
    // √âviter la duplication des souscriptions sauf si forc√©
    if (this.subscriptions.length > 0 && !force) {
      console.log('‚ö†Ô∏è  Souscriptions d√©j√† initialis√©es, ignorer');
      return;
    }

    // Si forc√©, nettoyer d'abord les anciennes souscriptions
    if (force && this.subscriptions.length > 0) {
      console.log('üîÑ Nettoyage des anciennes souscriptions avant r√©initialisation');
      this.subscriptions.forEach(sub => {
        if (sub && typeof sub.unsubscribe === 'function') {
          sub.unsubscribe();
        }
      });
      this.subscriptions = [];
    }

    console.log('üîÑ Initialisation des souscriptions...');
    
    // S'abonner au signal de reset explicite des participants
    const resetSub = this.quizService.participantsReset$.subscribe(reset => {
      if (reset) {
        console.log('[PRESENTATION] Signal de reset participants re√ßu, vidage de la liste');
        this.participants = [];
        try {
          localStorage.removeItem('presentation_participants_cache');
        } catch (e) {}
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(resetSub);

    // ‚úÖ S'abonner aux changements de questions
    const questionsSub = this.quizService.questions$.subscribe(questions => {
      if (questions.length > 0) {
        console.log(`[PRESENTATION-QUESTIONS] Nouvelle liste de questions re√ßue: ${questions.length} questions`);

        // Mettre √† jour la question courante si elle a chang√©
        const newCurrentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);
        if (newCurrentQuestion &&
            (!this.currentQuestion || this.currentQuestion.id !== newCurrentQuestion.id)) {

          console.log(`[PRESENTATION-QUESTIONS] Question ${this.currentIndex} mise √† jour:`, {
            ancien: this.currentQuestion?.text?.substring(0, 50) + '...',
            nouveau: newCurrentQuestion.text?.substring(0, 50) + '...'
          });

          this.currentQuestion = newCurrentQuestion;
        }
      }
    });
    this.subscriptions.push(questionsSub);

    // ‚úÖ S'abonner aux transitions d'√©tapes synchronis√©es via WebSocket
    const stepTransitionSub = this.websocketTimerService.getStepTransitions().subscribe(transitionData => {
      console.log('[PRESENTATION][STEP-WS] Transition re√ßue:', transitionData);
      this.showLoadingForTransition('question-start'); // Type par d√©faut pour les transitions
    });
    this.subscriptions.push(stepTransitionSub);

    const stepActivationSub = this.websocketTimerService.getStepActivations().subscribe(activationData => {
      console.log('[PRESENTATION][STEP-WS] Activation re√ßue:', activationData);

      // Gestion structure imbriqu√©e
      let stepValue = activationData.step;
      const rawData = activationData as any;
      if (!stepValue && rawData.data && rawData.data.step) {
        stepValue = rawData.data.step;
        console.log('[PRESENTATION][STEP-WS] √âtape extraite de structure imbriqu√©e:', stepValue);
      }

      console.log('[PRESENTATION][STEP-WS] √âtape finale:', stepValue);

      this.isLoading = false;
      this.step = stepValue as QuizStep;

      // Actions sp√©cifiques aux √©tapes apr√®s activation synchronis√©e
      this.handleStepActivationPresentation(stepValue as QuizStep);

      this.refresh();
      this.cdr.detectChanges();
    });
    this.subscriptions.push(stepActivationSub);

    // Synchro temps r√©el de l'√©tape du quiz (fallback pour compatibilit√©)
    let lastStep: string | null = null;
    const stepSub = this.quizService.getStep().subscribe(step => {
      if (!step || step === lastStep) return;

      console.log('[PRESENTATION][STEP-FALLBACK] Changement d\'√©tape :', lastStep, '->', step);
      lastStep = step;

      // Changement direct si WebSocket ne fonctionne pas
      this.step = step as QuizStep;
      this.handleStepActivationPresentation(step as QuizStep);
      this.refresh();
      this.cdr.detectChanges();
    });
    this.subscriptions.push(stepSub);

    // Synchro temps r√©el de l'index de la question
    const indexSub = this.quizService.getCurrentIndex().subscribe(async idx => {
      const previousIndex = this.currentIndex;
      this.currentIndex = idx;

      // Reset image states immediately when index changes to prevent flash
      if (previousIndex !== idx) {
        this.imageLoaded = false;
        this.resultImageLoaded = false;
        this.hideImages = false; // Allow images to show again for new question
        // Force immediate UI update to hide images instantly
        this.cdr.detectChanges();
        console.log('[DEBUG][INDEX] Image states reset for index change:', previousIndex, '->', idx);
      }

      await this.fetchQuestionStartTimes(); // Rafra√Æchit les timestamps √† chaque question
      this.refresh();
      
      // Synchro temps r√©el des votants pour la question courante
      try {
        const votersSub = this.quizService.getVoters$(idx).subscribe({
          next: (voters: {id: any, name: any}[]) => {
            if (voters && Array.isArray(voters)) {
              this.voters = voters;
            } else {
              console.warn('[PRESENTATION] Format de votants invalide:', voters);
              this.voters = [];
            }
          },
          error: (err) => {
            console.error('[PRESENTATION] Erreur dans la souscription des votants:', err);
            this.voters = [];
          }
        });
        this.subscriptions.push(votersSub);
      } catch (error) {
        console.error('[PRESENTATION] Erreur lors de la cr√©ation de la souscription des votants:', error);
      }

      // Synchro temps r√©el du nombre de r√©ponses par option
      if (this.answersCountSub) {
        this.answersCountSub.unsubscribe();
        this.answersCountSub = undefined;
      }
      
      try {
        console.log('[DEBUG][SUBSCRIPTION] Starting getAnswersCount$ subscription for question:', idx);
        this.answersCountSub = this.quizService.getAnswersCount$(idx).subscribe({
          next: (counts) => {
            if (counts && Array.isArray(counts)) {
              console.log('[DEBUG][SUBSCRIPTION] getAnswersCount$ returned:', counts);
              this.answersCount = counts;
              this.refresh();
            } else {
              console.warn('[PRESENTATION] Format de comptage des r√©ponses invalide:', counts);
              this.answersCount = [];
            }
          },
          error: (err) => {
            console.error('[PRESENTATION] Erreur dans la souscription du comptage des r√©ponses:', err);
            this.answersCount = [];
          }
        });
      } catch (error) {
        console.error('[PRESENTATION] Erreur lors de la cr√©ation de la souscription du comptage des r√©ponses:', error);
      }
      
      // Optimis√© : calcul du leaderboard sans logs excessifs
      this.updateLeaderboard();
    });
    this.subscriptions.push(indexSub);

    // Synchro temps r√©el des inscrits - optimis√© pour 60+ participants
    try {
      const participantsSub = this.quizService.getParticipants$().subscribe({
        next: (participants) => {
          if (!participants || !Array.isArray(participants)) {
            console.warn('[PRESENTATION] Format de participants invalide:', participants);
            return;
          }
          
          const oldCount = this.participants.length;
          
          // CORRECTION MAJEURE: V√©rification compl√®te des participants pour synchronisation des scores
          const hasNewParticipants = participants.some(p => !this.participants.find(oldP => oldP.id === p.id));
          if (hasNewParticipants) {
            // Nouveaux participants d√©tect√©s, rafra√Æchissement du leaderboard
            // Forcer une mise √† jour du leaderboard avec les nouveaux participants
            setTimeout(() => this.forceLeaderboardUpdate('nouveaux participants'), 500);
          }
          
          // Eviter les fluctuations si la liste est vide temporairement
          if (participants.length === 0 && oldCount > 0) {
            console.log('[PRESENTATION] Liste participants temporairement vide - conservation de la liste pr√©c√©dente');
            
            // V√©rifier avec le serveur avant de d√©cider
            this.quizService.fetchParticipantsFromServer().then(serverParticipants => {
              if (serverParticipants.length === 0) {
                // Derni√®re v√©rification avec le cache local avant de vider
                const cachedParticipantsStr = localStorage.getItem('presentation_participants_cache');
                if (cachedParticipantsStr) {
                  try {
                    const cachedList = JSON.parse(cachedParticipantsStr) as User[];
                    if (Array.isArray(cachedList) && cachedList.length > 0) {
                      console.log(`[PRESENTATION] Conservation des ${cachedList.length} participants du cache (serveur vide)`);
                      // Ne pas vider si nous avons un cache
                      return;
                    }
                  } catch (cacheError) {
                    console.warn('[PRESENTATION] Erreur lors de la lecture du cache final:', cacheError);
                  }
                }
                
                console.log('[PRESENTATION] Le serveur confirme que la liste est vide, mise √† jour');
                this.participants = [];
                this.cdr.detectChanges();
              } else {
                // Sinon utiliser la liste du serveur
                console.log(`[PRESENTATION] Liste du serveur: ${serverParticipants.length} participants`);
                this.participants = serverParticipants;
                this.cdr.detectChanges();
              }
              this.updateLeaderboard();
            }).catch(error => {
              console.warn('[PRESENTATION] Erreur lors de la v√©rification des participants:', error);
            });
            return; // Ne pas vider la liste si elle √©tait non-vide avant
          }

          // Copier les participants pour √©viter les r√©f√©rences
          this.participants = [...participants];
          const newCount = this.participants.length;

          if (oldCount !== newCount) {
            console.log(`[PRESENTATION] Participants: ${oldCount} ‚Üí ${newCount}`);
            this.cdr.detectChanges(); // Force la mise √† jour de l'interface
            
            // Mettre √† jour le cache si nous avons des participants
            if (newCount > 0) {
              try {
                localStorage.setItem('presentation_participants_cache', JSON.stringify(this.participants));
              } catch (cacheError) {
                console.warn('[PRESENTATION] Erreur lors de la mise √† jour du cache depuis l\'abonnement:', cacheError);
              }
            }
          }

          this.updateLeaderboard();
        },
        error: (err) => {
          console.error('[PRESENTATION] Erreur dans la souscription des participants:', err);
          
          // En cas d'erreur, essayer de restaurer depuis le cache
          this.restoreParticipantsFromCache();
        }
      });
      this.subscriptions.push(participantsSub);
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors de la cr√©ation de la souscription des participants:', error);
      
      // En cas d'erreur de cr√©ation, essayer de restaurer depuis le cache
      this.restoreParticipantsFromCache();
    }

    // ‚úÖ S'abonner aux mises √† jour WebSocket du timer pour la synchronisation visuelle c√¥t√© pr√©sentation
    const timerWebSocketSub = this.websocketTimerService.getCountdown().subscribe({
      next: (timerState) => {
        console.log('[PRESENTATION][TIMER-WS] Timer update re√ßu:', timerState);

        // Mettre √† jour l'affichage du timer c√¥t√© pr√©sentation quand il est actif
        if (timerState.questionStartTime && timerState.questionStartTime > 0 && this.step === 'question') {
          this.timerValue = timerState.timeRemaining;
          this.timerMax = timerState.timerMax;
          this.timerActive = timerState.isActive;

          // Si le timer est d√©marr√© c√¥t√© serveur, marquer comme d√©marr√© manuellement
          if (!this.timerStartedManually) {
            this.timerStartedManually = true;
            console.log('[PRESENTATION][TIMER-WS] Timer d√©marr√© d√©tect√©, timerStartedManually = true');
          }

          // Mise √† jour visuelle imm√©diate
          this.cdr.detectChanges();

          console.log('[PRESENTATION][TIMER-WS] Timer visuel mis √† jour:', {
            timeRemaining: this.timerValue,
            isActive: this.timerActive,
            timerMax: this.timerMax
          });
        } else if (timerState.questionStartTime === 0 && this.step === 'question') {
          // Timer pas encore d√©marr√©, r√©initialiser l'affichage
          this.timerActive = false;
          this.timerValue = timerState.timerMax || 20;
          this.timerStartedManually = false;
          console.log('[PRESENTATION][TIMER-WS] Timer en attente, timerStartedManually = false');
          this.cdr.detectChanges();
        }
      },
      error: (err) => {
        console.error('[PRESENTATION] Erreur dans la souscription du timer WebSocket:', err);
      }
    });
    this.subscriptions.push(timerWebSocketSub);
  }

  // Retourne le temps total des bonnes r√©ponses pour un user
  public getTotalGoodAnswersTime(userId: string): number {
    const arr = this.goodAnswersTimesByUser[userId] || [];
    return arr.reduce((sum, t) => sum + (t || 0), 0);
  }
  
  // M√©thode pour v√©rifier si le score d'un joueur a chang√© r√©cemment
  public hasScoreChanged(playerId: string): boolean {
    if (!this.lastSuccessfulLeaderboard || !this.scoreCache) {
      return false;
    }
    
    // Trouver l'entr√©e actuelle dans le leaderboard
    const currentEntry = this.leaderboard.find(entry => entry.id === playerId);
    
    // Trouver l'entr√©e pr√©c√©dente dans le dernier leaderboard r√©ussi
    const previousEntry = this.lastSuccessfulLeaderboard.find(entry => entry.id === playerId);
    
    // R√©cup√©rer les scores du cache √©galement
    const currentCachedScore = this.leaderboardCacheService.getCachedScore(playerId);
    const previousCachedScore = previousEntry?.score || 0;
    
    // V√©rifier si le score a chang√© (comparer √† la fois les entr√©es de leaderboard et les scores en cache)
    if (currentEntry && previousEntry) {
      // Soit le score dans le leaderboard a augment√©
      if (currentEntry.score > previousEntry.score) {
        return true;
      }
      // Soit le score en cache a augment√© par rapport au pr√©c√©dent score connu
      if (currentCachedScore > previousCachedScore) {
        return true;
      }
    }
    
    return false;
  }
  
  // M√©thode pour forcer la mise √† jour du leaderboard (utile apr√®s les r√©sultats d'une question)
  public forceLeaderboardUpdate(reason: string = 'demande manuelle') {
    console.log(`[SCORE][FORCE-UPDATE] For√ßage de la mise √† jour du leaderboard: ${reason}`);
    
    // V√©rification de l'√©tat actuel du leaderboard
    if (this.leaderboard.length > 0) {
      const scoresNonNuls = this.leaderboard.filter(entry => entry.score > 0);
      console.log(`[SCORE][FORCE-UPDATE] √âtat actuel: ${scoresNonNuls.length}/${this.leaderboard.length} joueurs avec score > 0`);
    }
    
    // Rafra√Æchissement des donn√©es des participants pour s'assurer d'avoir tous les joueurs
    this.refreshParticipants().catch(error => {
      console.warn('[SCORE][FORCE-UPDATE] Erreur lors du rafra√Æchissement des participants:', error);
    });
    
    // V√©rification et restauration du cache si n√©cessaire (√©tapes r√©sultat et fin)
    if (this.step === 'result' || this.step === 'end') {
      const hasScores = this.leaderboard.some(entry => entry.score > 0);
      const hasCache = this.lastSuccessfulLeaderboard.length > 0;
      
      if (!hasScores && hasCache) {
        console.log('[SCORE][FORCE-UPDATE] Restauration depuis le cache car aucun score > 0');
        this.leaderboard = JSON.parse(JSON.stringify(this.lastSuccessfulLeaderboard));
        this.cdr.detectChanges();
      }
    }
    
    // Premier appel imm√©diat de la mise √† jour
    this.updateLeaderboard();
    console.log('[SCORE][FORCE-UPDATE] Premier appel updateLeaderboard effectu√©');
    
    // Cycle de v√©rifications multiples avec d√©lais croissants
    const cycles = [
      { delay: 200, label: 'cycle rapide' },
      { delay: 500, label: 'cycle interm√©diaire' },
      { delay: 1000, label: 'cycle final' }
    ];
    
    cycles.forEach(cycle => {
      setTimeout(() => {
        console.log(`[SCORE][FORCE-UPDATE] Ex√©cution ${cycle.label} (${cycle.delay}ms)`);
        this.updateLeaderboard();
        this.cdr.detectChanges();
        
        // Logs des scores apr√®s mise √† jour
        const scoresPositifs = this.leaderboard.filter(entry => entry.score > 0).length;
        console.log(`[SCORE][FORCE-UPDATE] Apr√®s ${cycle.label}: ${scoresPositifs}/${this.leaderboard.length} joueurs avec score > 0`);
      }, cycle.delay);
    });
    
    // Mise √† jour finale apr√®s un d√©lai plus long pour s'assurer que toutes les donn√©es sont trait√©es
    setTimeout(() => {
      console.log('[SCORE][FORCE-UPDATE] Mise √† jour finale apr√®s d√©lai long');
      this.updateLeaderboard();
      this.cdr.detectChanges();
    }, 1500);
  }

  // M√©thode optimis√©e pour mettre √† jour le leaderboard sans logs excessifs
  private updateLeaderboard(): void {
    // Si pas de participants, essayer de charger depuis le cache avant d'abandonner
    if (this.participants.length === 0) {
      const cachedLeaderboard = this.leaderboardCacheService.getCachedLeaderboard();
      if (cachedLeaderboard && cachedLeaderboard.length > 0) {
        this.leaderboard = [...cachedLeaderboard];
        this.cdr.detectChanges();
        return;
      }
      this.leaderboard = [];
      return;
    }
    
    // D√©but de la mise √† jour du tableau de classement
    
    // Log plus d√©taill√© pour indiquer l'√©tat actuel avant mise √† jour
    // V√©rification silencieuse de l'√©tat actuel

    this.fetchQuestionStartTimes().then(() => {
      const subscription = this.quizService.getAllAnswers$().subscribe((allAnswersDocs: any[]) => {
        const nbQuestions = this.quizService.getQuestions().length;

        // Si pas de questions, pas de leaderboard
        if (nbQuestions === 0) {
          this.leaderboard = [];
          return;
        }

        // Mise √† jour du classement silencieuse
        
        // Afficher les IDs des questions par rapport √† leur index pour faciliter le d√©bogage
        const questionsMapping = this.quizService.getQuestions();
        // Mapping des index aux IDs de questions (log supprim√©)
          
        // CORRECTION: Analyser en d√©tail les incoh√©rences potentielles entre ID et index
        const idMismatchDetails = questionsMapping
          .map((q, idx) => ({ index: idx, id: q.id, correctIndex: q.correctIndex, hasMismatch: q.id !== idx }))
          .filter(q => q.hasMismatch);
          
        if (idMismatchDetails.length > 0) {
          // D√©tection silencieuse des incoh√©rences entre ID et index
        }
      

        // V√©rifie qu'il y a au moins une r√©ponse valide dans le jeu (pas forc√©ment pour tous les participants)
        let hasValidAnswer = false;
        
        // DEBUG: Afficher un r√©sum√© complet des documents de r√©ponses
        // Traitement silencieux des documents de r√©ponses
        
        // V√©rifier d'abord s'il y a des r√©ponses valides dans les donn√©es re√ßues
        if (this.totalAnswers > 0 && this.answersCount && this.answersCount.some(count => count > 0)) {
          hasValidAnswer = true;
          // D√©tection silencieuse des r√©ponses
        }
        
        // Si aucune r√©ponse n'est d√©tect√©e via answersCount, chercher dans les documents de r√©ponses
        if (!hasValidAnswer) {
          for (const doc of allAnswersDocs) {
            if (doc && doc.answers && doc.answers.length > 0) {
              for (const answer of doc.answers) {
                if (typeof answer.answerIndex !== 'undefined' && Number(answer.answerIndex) !== -1) {
                  hasValidAnswer = true;
                  // R√©ponse valide trouv√©e silencieusement
                  break;
                }
              }
              if (hasValidAnswer) break;
            }
          }
        }
        
        if (!hasValidAnswer) {
          this.leaderboard = [];
          // Aucune r√©ponse valide, leaderboard masqu√©
          return;
        }
        
        // Traitement des r√©ponses valides et calcul du classement

        // Log pour analyser la structure des donn√©es
        const questions = this.quizService.getQuestions();
        // Questions charg√©es pour le calcul du classement

        // CORRECTION: V√©rifier s'il y a une incoh√©rence entre les IDs des questions et leur index
        const hasIdMismatch = questions.some((q, idx) => q.id !== idx);
        if (hasIdMismatch) {
          // V√©rification des IDs de questions vs index
        }

        const leaderboard: LeaderboardEntry[] = this.participants.map(user => {
          let score = 0;
          let totalTime = 0;
          let goodTimes: number[] = [];

          // Calcul du score pour chaque utilisateur

          // Si nous sommes dans l'√©cran de r√©sultat d'une question sp√©cifique,
          // on peut mettre en √©vidence les performances sur cette question
          let currentQuestionCorrect = false;
          
          // DEBUG: Afficher un r√©sum√© complet pour ce joueur
          // Analyse des r√©ponses pour cet utilisateur
          
          for (let i = 0; i < nbQuestions; i++) {
            // Trouver le document de r√©ponse correspondant √† cet index de question
            // CORRECTION: Chercher par index i puisque les documents sont index√©s par ordre de question (0, 1, 2...)
            const docAns = allAnswersDocs.find((d: any) => Number(d.id) === i);
            
            // Log d√©taill√© pour cette question
            // Analyse silencieuse des documents de r√©ponses
            if (docAns && docAns.answers) {
              // Filtrer les r√©ponses pour cet utilisateur
              const answers = docAns.answers.filter((a: any) => String(a.userId) === String(user.id));
              if (answers.length > 0) {
                // Prendre la derni√®re r√©ponse (la plus r√©cente)
                const answer = answers[answers.length - 1];
                
                // CORRECTION: R√©cup√©rer la question par son index mais v√©rifier aussi son ID
                // Les indices des questions dans le tableau peuvent ne pas correspondre √† leurs IDs
                const question = this.quizService.getCurrentQuestion(i);
                if (!question) {
                  // Question introuvable pour cet utilisateur
                  continue; // Passer √† la question suivante si celle-ci n'est pas trouv√©e
                }

                // CORRECTION: Logs plus d√©taill√©s pour faciliter le d√©bogage
                // Analyse silencieuse des d√©tails de la question et de la r√©ponse

                // V√©rification que la question et la r√©ponse sont valides
                if (question && typeof answer.answerIndex !== 'undefined') {
                  
                  // CORRECTION: V√©rification stricte des types et conversion explicite
                  const answerIdx = typeof answer.answerIndex === 'string' ? parseInt(answer.answerIndex) : Number(answer.answerIndex);
                  const correctIdx = Number(question.correctIndex);
                  
                  // CORRECTION MAJEURE: V√©rification am√©lior√©e avec plusieurs strat√©gies de comparaison
                  const normalizedAnswerIdx = answerIdx;
                  const normalizedCorrectIdx = correctIdx;
                  
                  // Plusieurs conditions de validit√© pour √™tre plus flexible
                  let isCorrect = false;
                  let correctionStrategy = 'standard';
                  
                  // CORRECTION MAJEURE: Nouvelles strat√©gies de comparaison pour g√©rer les incoh√©rences entre IDs et index
                  
                  // 1. Comparaison directe standard (apr√®s normalisation)
                  if (!isNaN(normalizedAnswerIdx) && !isNaN(normalizedCorrectIdx) && normalizedAnswerIdx === normalizedCorrectIdx) {
                    isCorrect = true;
                    correctionStrategy = 'comparaison directe';
                  }
                  // 2. Comparaison additionelle en cas d'ID de question diff√©rent de l'index
                  else if (question.id !== i && !isNaN(normalizedAnswerIdx) && !isNaN(normalizedCorrectIdx)) {
                    // Si l'ID de question diff√®re de son index, essayer plusieurs strat√©gies
                    
                    // 2.1 V√©rifier si l'answerIndex correspond √† l'ID (cas le plus fr√©quent)
                    if (normalizedAnswerIdx === Number(question.correctIndex)) {
                      isCorrect = true;
                      correctionStrategy = 'comparaison correctIndex';
                    }
                    // 2.2 V√©rifier si l'answerIndex correspond √† l'ID de la question (cas sp√©cifique)
                    else if (normalizedAnswerIdx === question.id && question.id === Number(question.correctIndex)) {
                      isCorrect = true;
                      correctionStrategy = 'comparaison ID';
                    }
                    // 2.3 Enfin, force la v√©rification directe par valeur pour les cas marginaux
                    else if (answer.answerIndex !== undefined && 
                             Number(answer.answerIndex) === Number(question.correctIndex)) {
                      isCorrect = true;
                      correctionStrategy = 'comparaison valeur';
                    }
                  }
                  // 3. Comparaison suppl√©mentaire pour traiter les cas particuliers
                  else if (answer.answerIndex !== undefined && question.correctIndex !== undefined && 
                          Number(answer.answerIndex) === Number(question.correctIndex)) {
                    isCorrect = true;
                    correctionStrategy = 'comparaison directe stricte';
                  }
                  
                  // CORRECTION: Ajouter plus d'informations sur la question pour d√©bogage
                  // Analyse silencieuse des types de donn√©es pour la v√©rification des r√©ponses
                  
                  // CORRECTION: V√©rification plus stricte avec gestion des types et valeurs
                  // Assurons-nous que les indices sont des nombres valides
                  if (isCorrect) {
                    // Incr√©menter le score de fa√ßon plus explicite avec log pour faciliter le d√©bogage
                    score++;
                    
                    console.log(`[SCORE] Utilisateur ${user.name} (ID=${user.id}) a obtenu un point pour la question ${i} (ID=${question.id}). Strat√©gie: ${correctionStrategy}`);
                    
                    // CORRECTION FINALE: Mettre √† jour le cache des scores pour cet utilisateur
                    const currentCachedScore = this.leaderboardCacheService.getCachedScore(user.id);
                    if (score > currentCachedScore) {
                      console.log(`[SCORE] Mise √† jour du score en cache pour ${user.name}: ${currentCachedScore} -> ${score}`);
                      // Le score calcul√© est meilleur que celui en cache, le mettre √† jour imm√©diatement
                      // Mise √† jour du cache pour un meilleur score
                      // Mettre √† jour directement le cache sans attendre la fin du calcul
                      this.leaderboardCacheService.updateCache([{
                        id: user.id,
                        name: user.name,
                        score: score,
                        totalTime: totalTime,
                        avatarUrl: user.avatarUrl
                      }]);
                      
                      // Diffuser le nouveau score via WebSocket pour une synchronisation imm√©diate
                      try {
                        this.websocketTimerService.sendUserScore({
                          userId: user.id,
                          userName: user.name,
                          score: score,
                          questionIndex: i,
                          avatarUrl: user.avatarUrl,
                          timestamp: Date.now()
                        });
                        console.log(`[SCORE] Score ${score} diffus√© via WebSocket pour ${user.name}`);
                      } catch (wsError) {
                        console.error(`[SCORE] Erreur envoi WebSocket pour ${user.name}:`, wsError);
                      }
                    }
                  }
                  
                  // Log de debug am√©lior√© pour voir l'incr√©mentation du score
            // Traitement silencieux des r√©ponses correctes
                    
                    // Log sp√©cifique pour les utilisateurs ayant exactement 1 point (aide au d√©bogage)
                    if (score === 1) {
                      // Premier point obtenu pour cet utilisateur
                    }
                    
                    // Marquer sp√©cifiquement si c'est la question courante qui est correcte
                    if (i === this.currentIndex) {
                      currentQuestionCorrect = true;
                    }
                    
                    const qStart = this.questionStartTimes[i] ?? this.questionStartTimes[String(i)];
                    if (answer.timestamp && qStart && answer.timestamp >= qStart) {
                      const timeTaken = Math.min(answer.timestamp - qStart, 20000);
                      goodTimes[i] = timeTaken;
                      totalTime += timeTaken;
                    }
                  } else {
                    // Log de debug pour voir les r√©ponses incorrectes
                    // Traitement silencieux des r√©ponses incorrectes
                    goodTimes[i] = undefined as any;
                  }
                }
              } else {
                goodTimes[i] = undefined as any;
              }
            } else {
              goodTimes[i] = undefined as any;
            }
          }

          // Finalisation du calcul du score

          this.goodAnswersTimesByUser[user.id] = goodTimes;
          
          // AM√âLIORATION: Gestion prioritaire du calcul de score sur le cache
          // Priorit√© 1: Toujours utiliser le score calcul√© s'il est non nul
          if (score > 0) {
            // Utilisation prioritaire du score calcul√©
            
            // Mettre √† jour les caches avec le score calcul√©
            const serviceCachedScore = this.leaderboardCacheService.getCachedScore(user.id);
            const localCachedScore = this.scoreCache[user.id]?.score || 0;
            
            // Ne mettre √† jour le cache que si le score calcul√© est plus grand
            if (score > serviceCachedScore) {
              // Mise √† jour du cache service
              // Ce cache sera mis √† jour √† la fin avec le leaderboard complet
            }
            
            // Mettre √† jour √©galement le cache local
            if (score > localCachedScore) {
              this.scoreCache[user.id] = {
                score: score,
                timestamp: Date.now()
              };
              // Mise √† jour du cache local
            }
          } 
          // Priorit√© 2: Si score calcul√© est 0, v√©rifier les caches
          else {
            // V√©rifier d'abord le cache du service
            const serviceCachedScore = this.leaderboardCacheService.getCachedScore(user.id);
            // Puis le cache local
            const localCachedScore = this.scoreCache[user.id]?.score || 0;
            
            // Utiliser le meilleur score disponible dans les caches
            const bestCachedScore = Math.max(serviceCachedScore, localCachedScore);
            
            if (bestCachedScore > 0) {
              // Utilisation du cache pour score nul
              score = bestCachedScore;
            }
          }
          
          return { 
            id: user.id, 
            name: user.name, 
            avatarUrl: user.avatarUrl, 
            score, 
            totalTime,
            // Ajouter un indicateur pour la question courante
            currentQuestionCorrect
          };
        });

        // CORRECTION MAJEURE: V√©rification de l'√©tat du leaderboard avant mise √† jour
        const previousLeaderboard = this.leaderboard || [];
        
        // Traiter les donn√©es de leaderboard avant assignation
        const sortedLeaderboard = leaderboard.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.totalTime - b.totalTime;
        });
        
        // V√©rifier s'il y a des changements dans les scores
        let scoresChanged = false;
        if (previousLeaderboard.length !== sortedLeaderboard.length) {
          scoresChanged = true;
        } else {
          for (let i = 0; i < sortedLeaderboard.length; i++) {
            if (!previousLeaderboard[i] || previousLeaderboard[i].score !== sortedLeaderboard[i].score) {
              scoresChanged = true;
              // Changement de score d√©tect√©
              break;
            }
          }
        }
        
        // AM√âLIORATION: Logs d√©taill√©s avant mise √† jour du leaderboard
        // Comparaison silencieuse avant mise √† jour
        
        // Comparer les scores actuels avec les nouveaux scores
        if (this.leaderboard.length > 0) {
          sortedLeaderboard.slice(0, Math.min(5, sortedLeaderboard.length)).forEach((newEntry, idx) => {
            const oldEntry = this.leaderboard.find(e => e.id === newEntry.id);
            if (oldEntry) {
              const scoreChanged = oldEntry.score !== newEntry.score;
              // Analyse silencieuse des changements de score
            } else {
              // Nouveau score initial d√©tect√©
            }
          });
        } else {
          // Aucun leaderboard pr√©c√©dent pour comparaison
        }
        
        // CORRECTION MAJEURE: Pr√©server les scores WebSocket avant d'assigner le nouveau leaderboard
        const webSocketScores: { [userId: string]: number } = {};
        
        // Conserver les scores actuels du leaderboard qui viennent du WebSocket
        this.leaderboard.forEach(entry => {
          const cachedScore = this.leaderboardCacheService.getCachedScore(entry.id);
          if (cachedScore > 0) {
            webSocketScores[entry.id] = cachedScore;
            console.log(`[SCORE] Pr√©servation du score WebSocket pour ${entry.name}: ${cachedScore}`);
          }
        });
        
        // Cr√©er une copie profonde du nouveau leaderboard calcul√©
        const newLeaderboard = JSON.parse(JSON.stringify(sortedLeaderboard));
        
        // Appliquer les scores WebSocket pr√©serv√©s au nouveau leaderboard
        newLeaderboard.forEach((entry: LeaderboardEntry) => {
          if (webSocketScores[entry.id] !== undefined && webSocketScores[entry.id] > entry.score) {
            console.log(`[SCORE] Priorit√© au score WebSocket pour ${entry.name}: ${entry.score} -> ${webSocketScores[entry.id]}`);
            entry.score = webSocketScores[entry.id];
          }
        });
        
        // V√©rifier si des participants avec des scores WebSocket ne sont pas dans le nouveau leaderboard
        const participantIds = newLeaderboard.map((entry: LeaderboardEntry) => entry.id);
        Object.keys(webSocketScores).forEach(userId => {
          if (!participantIds.includes(userId) && webSocketScores[userId] > 0) {
            // Trouver le participant manquant
            const participant = this.participants.find(p => p.id === userId);
            if (participant) {
              console.log(`[SCORE] Ajout d'un participant manquant avec score WebSocket: ${participant.name}: ${webSocketScores[userId]}`);
              newLeaderboard.push({
                id: participant.id,
                name: participant.name,
                score: webSocketScores[userId],
                avatarUrl: participant.avatarUrl,
                totalTime: 0,
                currentQuestionCorrect: false
              });
            }
          }
        });
        
        // Trier √† nouveau le leaderboard apr√®s application des scores WebSocket
        newLeaderboard.sort((a: LeaderboardEntry, b: LeaderboardEntry) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.totalTime - b.totalTime;
        });
        
        // Assigner le leaderboard final
        this.leaderboard = newLeaderboard;
        
        // AM√âLIORATION: Visualisation des scores finaux
        console.log(`[SCORE] Leaderboard final apr√®s pr√©servation des scores WebSocket:`, 
                    this.leaderboard.map(e => `${e.name}: ${e.score}`).join(', '));
        // Traitement silencieux des scores apr√®s mise √† jour
        
        // CORRECTION FINALE: Mettre √† jour le cache si des scores valides sont pr√©sents
        if (this.leaderboard.length > 0 && this.leaderboard.some(entry => entry.score > 0)) {
          // Mise √† jour du cache avec les entr√©es valides
          this.leaderboardCacheService.updateCache(this.leaderboard);
        } else {
          // Pas de mise √† jour du cache - Aucun score valide
        }
        
        // CORRECTION FINALE: Si le leaderboard semble valide, le conserver comme r√©f√©rence
        if (this.leaderboard.length > 0 && this.leaderboard.some(entry => entry.score > 0)) {
          // Sauvegarde du tableau de classement valide
          this.lastSuccessfulLeaderboard = JSON.parse(JSON.stringify(this.leaderboard));
          
          // Sauvegarder dans le localStorage pour persistance
          try {
            localStorage.setItem('leaderboard_cache', JSON.stringify(this.lastSuccessfulLeaderboard));
            // Leaderboard sauvegard√© dans le localStorage
          } catch (error) {
            // Gestion silencieuse des erreurs de cache
          }
        }

        // Log d√©taill√© du leaderboard final
        // Tableau de classement mis √† jour
        
        // Logs d√©taill√©s pour les 3 premiers joueurs (limit√© pour √©viter la surcharge)
        if (this.leaderboard.length > 0) {
          // Traitement silencieux des meilleurs joueurs
        }
        
        // Force une d√©tection de changement imm√©diate
        this.cdr.detectChanges();
        
        // Si des scores ont chang√©, program une seconde v√©rification
        if (scoresChanged) {
          setTimeout(() => {
            // V√©rification secondaire apr√®s changement de scores
            // Seconde d√©tection de changement pour s'assurer que l'UI est √† jour
            this.cdr.detectChanges();
          }, 500);
        }
      });

      this.subscriptions.push(subscription);
    });
  }

  // R√©cup√®re les questionStartTimes via l'API HTTP
  public async fetchQuestionStartTimes(): Promise<void> {
    try {
      // TODO: Impl√©menter une m√©thode API pour r√©cup√©rer les timestamps
      // console.log('[INFO] fetchQuestionStartTimes temporarily disabled - needs API implementation');
      this.questionStartTimes = {};
    } catch (e) {
      console.warn('Erreur r√©cup√©ration questionStartTimes', e);
    }
  }

//   forceEndTimer() {
//     // Appel backend pour forcer la fin du timer chez tous les joueurs
//     try {
//   this.http.post('/api/quiz/skip-timer', {}, { responseType: 'json' }).subscribe({
//         next: (response) => {
//           console.log('[SKIP-TIMER] R√©ponse backend (type):', typeof response, response);
//           try {
//             if (response && (response as any).success) {
//               this.timerValue = 0;
//               this.stopTimer();
//               this.showResult();
//             } else {
//               alert('R√©ponse inattendue du backend : ' + JSON.stringify(response));
//             }
//           } catch (e) {
//             alert('Erreur de parsing de la r√©ponse backend : ' + e);
//           }
//         },
//         error: (err) => {
//           console.error('[SKIP-TIMER] Erreur HTTP :', err);
//           let msg = 'Erreur lors du skip timer : ';
//           if (err.status) msg += `HTTP ${err.status} - `;
//           if (err.error && typeof err.error === 'object') {
//             msg += JSON.stringify(err.error);
//           } else if (err.error) {
//             msg += err.error;
//           } else if (err.message) {
//             msg += err.message;
//           }
//           if (err instanceof ProgressEvent && err.type === 'error') {
//             msg += ' (Erreur r√©seau/fetch : la connexion a √©chou√© ou a √©t√© bloqu√©e par le navigateur)';
//           }
//           alert(msg);
//         }
//       });
//     } catch (e) {
//       alert('Erreur JS lors de l‚Äôappel skip-timer : ' + e);
//       console.error('[SKIP-TIMER] Exception JS :', e);
//     }
//   }

  // ngOnInit fusionn√© ci-dessus

  refresh() {
    // this.participants = ... supprim√©, car synchro via API SQLite
    const previousQuestion = this.currentQuestion;
    this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

    // Reset image loaded state IMMEDIATELY when question changes to prevent flash
    if (previousQuestion?.id !== this.currentQuestion?.id) {
      this.imageLoaded = false;
      this.resultImageLoaded = false;
      this.hideImages = false; // Allow images to show for new question
      console.log('[DEBUG][REFRESH] Image states reset due to question change');
    }

    // Ne pas √©craser le leaderboard dynamique ici !

    console.log('[DEBUG][REFRESH] currentQuestion:', this.currentQuestion);
    console.log('[DEBUG][REFRESH] answersCount:', this.answersCount);
    console.log('[DEBUG][REFRESH] currentIndex:', this.currentIndex);

    if (this.currentQuestion && this.answersCount) {
      console.log('[DEBUG][REFRESH] correctIndex:', this.currentQuestion.correctIndex);
      this.totalGood = this.answersCount[this.currentQuestion.correctIndex] || 0;
      this.totalAnswers = this.answersCount.reduce((a, b) => a + b, 0);
      this.totalBad = this.totalAnswers - this.totalGood;

      console.log('[DEBUG][REFRESH] Calculated values:', {
        totalGood: this.totalGood,
        totalBad: this.totalBad,
        totalAnswers: this.totalAnswers
      });
    } else {
      this.totalGood = 0;
      this.totalAnswers = 0;
      this.totalBad = 0;
      console.log('[DEBUG][REFRESH] Reset to 0 - missing currentQuestion or answersCount');
    }
  }

  async launchGame() {
    // Rafra√Æchir la liste des participants une derni√®re fois avant de lancer le jeu
    console.log('[PRESENTATION] Rafra√Æchissement des participants avant le lancement du jeu...');
    await this.refreshParticipants();
    
    // Passe √† l'√©tape "waiting" avant de lancer la premi√®re question
    this.quizService.setStep('waiting');
  }

  // M√©thode √† appeler pour vraiment d√©marrer la premi√®re question apr√®s l'attente
  async startFirstQuestion() {
    // D√©marre la premi√®re question via l'API HTTP
    try {
      // Utilise nextQuestion(-1) pour forcer le passage √† l'index 0 avec initialisation du timer
      await this.quizService.nextQuestion(-1);
      console.log('[INFO] First question started via HTTP API');
    } catch (error) {
      console.error('Erreur lors du d√©marrage de la premi√®re question:', error);
    }
  }

  startTimer() {
    this.stopTimer();
    this.syncTimerWithServer();
  }

  private async checkAndSyncTimer() {
    try {
      const gameState = await this.quizService.getGameState();

      if (gameState?.questionStartTime) {
        // Le serveur a d√©j√† un questionStartTime, synchroniser
        console.log('üïê Question d√©j√† d√©marr√©e c√¥t√© serveur, synchronisation...');
        this.syncTimerWithServer();
      } else {
        // Pas de questionStartTime c√¥t√© serveur, ne pas d√©marrer le timer
        console.log('‚è∏Ô∏è Pas de timer c√¥t√© serveur, service centralis√© g√®re l\'√©tat');
        // Le service centralis√© g√®re l'√©tat par d√©faut
      }
    } catch (error) {
      console.warn('Erreur v√©rification timer serveur, service centralis√© prend le relais:', error);
      // Le service centralis√© g√®re l'√©tat par d√©faut en cas d'erreur
    }
  }

  private async syncTimerWithServer() {
    try {
      console.log('üïê [PRESENTATION] Synchronisation timer centralis√©e (auto-d√©marrage)');

      // S'abonner aux mises √† jour du timer centralis√© (d√©marrage automatique)
      if (this.timerSub) this.timerSub.unsubscribe();

      this.timerSub = this.timerService.getCountdown().subscribe(timerState => {
        const countdown = timerState.countdownToStart || 0;

        if (countdown > 0) {
          // Mode countdown avant d√©marrage
          this.timerValue = countdown;
          this.timerMax = countdown;
          console.log(`‚è≥ [PRESENTATION] Countdown: Question d√©marre dans ${countdown}s`);
        } else {
          // Mode timer normal
          this.timerValue = timerState.timeRemaining;
          this.timerMax = timerState.timerMax;
          console.log(`üïê [PRESENTATION] Timer: ${timerState.timeRemaining}s/${timerState.timerMax}s, active: ${timerState.isActive}`);

          if (timerState.timeRemaining <= 0 && timerState.isActive === false) {
            this.showResult();
          }
        }
      });

      // Le service centralis√© g√®re la synchronisation initiale automatiquement
      console.log('üïê [PRESENTATION] Service centralis√© actif, synchronisation automatique');

    } catch (error) {
      console.warn('Erreur synchronisation timer, fallback au service centralis√©:', error);
      // Fallback: utiliser le service centralis√© avec d√©marrage simple
      this.timerService.start(20);
    }
  }

  // DEPRECATED: Ancienne m√©thode remplac√©e par le service timer centralis√©
  private startTimerNormal_DEPRECATED(duration: number = 20) {
    console.warn('‚ö†Ô∏è startTimerNormal_DEPRECATED appel√©e - utiliser le service centralis√© √† la place');
    // Ne plus utiliser cette m√©thode, utiliser timerService.startServerSync() √† la place
    this.timerService.start(duration);
  }

  stopTimer() {
    if (this.timerSub) this.timerSub.unsubscribe();
    this.timerService.stopServerSync(); // Arr√™ter la synchronisation centralis√©e
  }

  showResult() {
    console.log('[DEBUG][IMAGE] Pr√©paration affichage des r√©sultats');
    
    // On cache temporairement les images pendant la transition
    this.hideImages = true;
    this.imageLoaded = false;
    // Ne pas r√©initialiser resultImageLoaded ici pour √©viter le clignotement
    // Force immediate UI update to hide images instantly
    this.cdr.detectChanges();
    
    // CORRECTION MAJEURE: Forcer une mise √† jour compl√®te du leaderboard lors du passage aux r√©sultats
    // avec une s√©quence de v√©rifications pour garantir la synchronisation
    console.log('[PR√âSENTATION] Passage √† l\'\'√©tape de r√©sultat - S√©quence de mise √† jour du leaderboard');
    
    // Mise √† jour imm√©diate
    this.forceLeaderboardUpdate('passage initial √† l\'\'√©tape r√©sultat');
    
    // S√©rie de mises √† jour avec d√©lais croissants pour s'assurer que les donn√©es sont prises en compte
    const updateIntervals = [500, 1000, 2000];
    updateIntervals.forEach(delay => {
      setTimeout(() => {
        // V√©rification p√©riodique des scores
        this.forceLeaderboardUpdate(`v√©rification apr√®s ${delay}ms`);
      }, delay);
    });

    // On force la mise √† jour des donn√©es avant d'afficher le r√©sultat
    const previousQuestion = this.currentQuestion;
    this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

    // answersCount est toujours √† jour via l'abonnement (voir ngOnInit)
    if (this.currentQuestion && this.answersCount && Array.isArray(this.answersCount)) {
      this.totalGood = this.answersCount[this.currentQuestion.correctIndex] || 0;
      this.totalAnswers = this.answersCount.reduce((a, b) => a + b, 0);
      this.totalBad = this.totalAnswers - this.totalGood;
    } else {
      this.totalGood = 0;
      this.totalAnswers = 0;
      this.totalBad = 0;
    }
    
    // CORRECTION: Mise √† jour p√©riodique du leaderboard apr√®s l'affichage des r√©sultats
    const refreshIntervalId = setInterval(() => {
      this.forceLeaderboardUpdate('rafra√Æchissement p√©riodique des r√©sultats');
    }, 1000);
    
    // Arr√™ter les rafra√Æchissements apr√®s 3 cycles
    setTimeout(() => {
      clearInterval(refreshIntervalId);
      // Fin des rafra√Æchissements p√©riodiques
      
      // Dernier rafra√Æchissement apr√®s l'arr√™t des intervalles
      this.forceLeaderboardUpdate('final apr√®s cycles');
    }, 3000);
    
    // Pr√©chargement de l'image de r√©sultat si disponible
    if (this.currentQuestion?.imageUrlResult) {
      console.log('[DEBUG][IMAGE] Pr√©chargement de l\'image r√©sultat:', this.currentQuestion.imageUrlResult);
      // R√©initialiser pour permettre le chargement de la nouvelle image
      this.resultImageLoaded = false;
    }
    
    // CORRECTION: Forcer une mise √† jour du leaderboard avant d'afficher les r√©sultats
    this.forceLeaderboardUpdate();
    
    // Passage √† l'√©tape r√©sultat avec d√©lai pour laisser le flux RxJS se mettre √† jour
    setTimeout(() => {
      this.quizService.setStep('result');
      this.step = 'result'; // Synchronisation imm√©diate pour le template
      
      // R√©activer l'affichage des images
      this.hideImages = false;
      
      this.refresh(); // Forcer la mise √† jour des donn√©es juste apr√®s le changement d'√©tape
      
      // CORRECTION: Forcer une seconde mise √† jour du leaderboard apr√®s le changement d'√©tape
      this.forceLeaderboardUpdate();
      
      this.cdr.markForCheck();
      // Log apr√®s le changement d'√©tape
      console.log('[DEBUG][RESULT] step:', this.step, 'currentQuestion:', this.currentQuestion, 'answersCount:', this.answersCount);
    }, 120);
  }

  async nextQuestion() {
    // Incr√©mente l'index et passe √† la question suivante via l'API
    try {
      console.log('[PRESENTATION] Next question via HTTP API, current index:', this.currentIndex);

      // Hide images immediately - most aggressive approach
      this.hideImages = true;
      this.imageLoaded = false;
      this.resultImageLoaded = false;

      // Reset timer immediately to sync with image change
      this.timerValue = 0;
      this.stopTimer();

      // Force immediate UI update to hide images instantly and show empty timer
      this.cdr.detectChanges();

      // Petit d√©lai pour laisser l'interface se mettre √† jour
      await new Promise(resolve => setTimeout(resolve, 50));

      // Reset timer to full immediately for visual sync
      this.timerValue = 20;
      this.timerMax = 20;
      this.cdr.detectChanges();

      // CORRECTION: Un seul appel qui g√®re tout (index + step + timer)
      await this.quizService.nextQuestion(this.currentIndex);
      console.log('[PRESENTATION] Question suivante appel√©e, nouvel index:', this.currentIndex + 1);
      
      // Forcer le rafra√Æchissement du leaderboard pour synchroniser les scores
      this.forceRefreshLeaderboard();
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors du passage √† la question suivante:', error);
    }
  }

  endGame() {
    this.quizService.setStep('end');
  }

  public async resetParticipants() {
    await this.quizService.resetParticipants();
  }

  // R√©initialisation compl√®te du quiz (√©tape, participants, index, r√©ponses, et cache)
  async restartGame() {
    if (!confirm('‚ö†Ô∏è R√âINITIALISATION COMPL√àTE ‚ö†Ô∏è\n\n√ätes-vous s√ªr de vouloir r√©initialiser compl√®tement le quiz ?\n\nCette action supprimera :\n- Tous les participants\n- Toutes les r√©ponses\n- Tous les caches locaux\n- L\'√©tat de la partie\n- Les sessions des utilisateurs')) {
      return;
    }

    console.log('[RESET] D√©but de la r√©initialisation compl√®te du quiz');

    try {
      // √âTAPE 1: Nettoyage COMPLET des caches locaux AVANT le reset serveur
      console.log('[RESET] 1. Suppression de tous les caches locaux...');
      try {
        // 1.1: Suppression du cache des participants
        localStorage.removeItem('presentation_participants_cache');
        console.log('[RESET] 1.1 ‚úÖ Cache local des participants supprim√©');
        
        // 1.2: Effacer l'√©tat du jeu sauvegard√© via GamePersistenceService
        this.quizService.clearSavedGameState();
        console.log('[RESET] 1.2 ‚úÖ √âtat du jeu sauvegard√© effac√©');
        
        // 1.3: Effacer toutes les informations utilisateur
        this.userStateService.clearUserInfo();
        console.log('[RESET] 1.3 ‚úÖ Informations utilisateur effac√©es');
        
        // 1.4: Nettoyage des cl√©s anciennes/compatibilit√©
        const legacyCacheKeys = [
          'currentQuestionIndex',
          'quizStep',
          'quiz_answers',
          'quiz_last_question',
          'quiz_state',
          'quiz_player_state',
          'quiz-user',
          'last_answers_sync',
          'timer_state'
        ];
        
        legacyCacheKeys.forEach(key => {
          if(localStorage.getItem(key)) {
            localStorage.removeItem(key);
            console.log(`[RESET] Cache suppl√©mentaire nettoy√©: ${key}`);
          }
        });
        
        console.log('[RESET] 1.4 ‚úÖ Caches additionnels nettoy√©s');
      } catch (cacheError) {
        console.warn('[RESET] ‚ö†Ô∏è Erreur lors de la suppression des caches:', cacheError);
      }

      // √âTAPE 2: Suppression des participants sur le serveur
      console.log('[RESET] 2. Suppression des participants sur le serveur...');
      await this.quizService.resetParticipants();
      console.log('[RESET] 2. ‚úÖ Participants supprim√©s sur le serveur');
      
      // √âTAPE 3: Reset des r√©ponses
      console.log('[RESET] 3. Reset des r√©ponses...');
      await this.quizService.resetAllAnswers();
      console.log('[RESET] 3. ‚úÖ R√©ponses supprim√©es');

      // √âTAPE 4: Passage forc√© √† l'√©tape lobby avec plusieurs tentatives
      console.log('[RESET] 4. Passage forc√© √† l\'√©tape lobby...');
      // Premier appel
      await this.quizService.setStep('lobby');
      // Petit d√©lai pour laisser le temps au WebSocket de traiter
      await new Promise(resolve => setTimeout(resolve, 500));
      // Second appel pour forcer
      await this.quizService.setStep('lobby');
      // Troisi√®me appel apr√®s un d√©lai plus long pour s'assurer de la propagation
      await new Promise(resolve => setTimeout(resolve, 1000));
      await this.quizService.setStep('lobby');
      console.log('[RESET] 4. ‚úÖ √âtape lobby d√©finie et rediffus√©e (3 fois)');

      // √âTAPE 5: Vider explicitement toutes les structures de donn√©es locales
      console.log('[RESET] 5. R√©initialisation locale de l\'√©tat...');
      // R√©initialisation locale de l'√©tat du composant
      this.step = 'lobby';
      this.currentIndex = 0;
      this.currentQuestion = null;
      this.answersCount = [];
      this.voters = [];
      this.leaderboard = [];
      this.participants = []; // Vider explicitement avant de recharger
      
      // Suppression explicite du cache des participants via le service
      this.quizService.clearParticipantsCache();
      console.log('[RESET] ‚úÖ Cache des participants supprim√© et signal envoy√©');
      
      // Double v√©rification du cache local
      try {
        localStorage.removeItem('presentation_participants_cache');
      } catch (cacheError) {
        console.warn('[RESET] ‚ö†Ô∏è Erreur lors de la suppression du cache des participants:', cacheError);
      }
      
      this.questionStartTimes = {};
      this.goodAnswersTimesByUser = {};
      this.imageLoaded = false; 
      this.resultImageLoaded = false;
      this.hideImages = false;
      this.timerValue = 20;
      this.timerMax = 20;
      this.timerActive = false;
      this.timerStartedManually = false;
      this.cachedParticipantsLoaded = false;
      this.cdr.detectChanges();
      console.log('[RESET] 5. ‚úÖ √âtat local r√©initialis√©');

      // √âTAPE 6: V√©rification finale - recharger les participants depuis le serveur
      console.log('[RESET] 6. V√©rification finale des participants...');
      
      // Faire plusieurs tentatives pour s'assurer que la liste est bien vide
      let participantsCount = -1;
      for (let attempt = 0; attempt < 3; attempt++) {
        console.log(`[RESET] Tentative ${attempt + 1}/3 de v√©rification des participants...`);
        const participants = await this.quizService.fetchParticipantsFromServer();
        participantsCount = participants ? participants.length : 0;
        
        if (participantsCount === 0) {
          console.log('[RESET] ‚úÖ Confirmation: la liste des participants est bien vide');
          this.participants = [];
          break;
        } else {
          console.warn(`[RESET] ‚ö†Ô∏è La liste contient encore ${participantsCount} participants, nouvelle tentative...`);
          // Petit d√©lai avant la prochaine tentative
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      
      if (participantsCount > 0) {
        console.warn(`[RESET] ‚ö†Ô∏è M√™me apr√®s plusieurs tentatives, il reste ${participantsCount} participants`);
        
        // Dernier recours: forcer une derni√®re r√©initialisation et vider la liste locale
        try {
          await this.quizService.resetParticipants();
          this.participants = [];
        } catch (lastError) {
          console.error('[RESET] ‚ùå √âchec de la derni√®re tentative de r√©initialisation:', lastError);
        }
      }

      // √âTAPE 7: Nettoyage complet des ressources et r√©initialisation des souscriptions
      console.log('[RESET] 7. Nettoyage des ressources et r√©initialisation des souscriptions...');
      // Nettoyer toutes les ressources sans sauvegarder les participants
      this.cleanupResources(false);
      
      // R√©initialiser les souscriptions
      this.initializeSubscriptions(true);
      console.log('[RESET] 7. ‚úÖ Ressources nettoy√©es et souscriptions r√©initialis√©es');

      // √âTAPE 8: V√©rification finale de la connexion WebSocket
      console.log('[RESET] 8. V√©rification finale de la connexion WebSocket...');
      try {
        // Forcer la d√©connexion puis la reconnexion pour garantir une connexion fra√Æche
        this.websocketTimerService.disconnect();
        
        // Attendre un peu avant de forcer la reconnexion
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // La reconnexion se fera automatiquement lors du prochain acc√®s
        console.log('[RESET] 8. ‚úÖ Connexion WebSocket r√©initialis√©e');
      } catch (wsError) {
        console.warn('[RESET] ‚ö†Ô∏è Erreur lors de la r√©initialisation WebSocket:', wsError);
      }
      
      // √âTAPE 9: Forcer une mise √† jour imm√©diate de l'interface
      console.log('[RESET] 9. For√ßage de la mise √† jour de l\'interface...');
      // S'assurer que la liste des participants est bien vide apr√®s le reset complet
      this.participants = [];
      
      // Forcer la d√©tection de changements imm√©diatement
      this.cdr.detectChanges();
      
      // Provoquer un cycle suppl√©mentaire de d√©tection de changements apr√®s un court d√©lai
      // pour garantir que l'affichage est √† jour
      setTimeout(() => {
        this.cdr.detectChanges();
        console.log('[RESET] 9. ‚úÖ Interface mise √† jour forc√©e');
      }, 100);
      
      // √âTAPE 10: Notification du succ√®s
      console.log('[RESET] ‚úÖ Quiz enti√®rement r√©initialis√© avec succ√®s');
      alert('Quiz enti√®rement r√©initialis√©. Tous les participants, r√©ponses et caches ont √©t√© supprim√©s.');

    } catch (error) {
      console.error('[RESET] ‚ùå Erreur lors de la r√©initialisation:', error);
      const errorMsg = error instanceof Error ? error.message : 'Erreur inconnue';
      alert(`Erreur lors de la r√©initialisation du quiz: ${errorMsg}`);
    }
    this.timerValue = 20;
    this.voters = [];

    this.refresh();
  }

  // M√©thodes de gestion des images pour √©viter le flash
  onImageLoaded() {
    this.imageLoaded = true;
  }

  onImageError() {
    this.imageLoaded = false;
    console.warn('Erreur de chargement de l\'image:', this.currentQuestion?.imageUrl);
  }

  onResultImageLoaded() {
    console.log('[DEBUG][IMAGE] Image r√©sultat charg√©e avec succ√®s');
    this.resultImageLoaded = true;
    // Force l'actualisation de l'interface pour afficher l'image
    this.cdr.detectChanges();
  }

  onResultImageError() {
    console.warn('[DEBUG][IMAGE] Erreur de chargement de l\'image r√©sultat:', this.currentQuestion?.imageUrlResult);
    this.resultImageLoaded = false;
    // Force l'actualisation de l'interface pour afficher le message d'erreur
    this.cdr.detectChanges();
  }

  // TrackBy function pour forcer la recr√©ation des √©l√©ments d'image
  trackByQuestionId(index: number, question: any): any {
    return question?.id || index;
  }

  // ===== M√âTHODES POUR LA PHOTO DE GROUPE =====

  async startCamera(): Promise<void> {
    try {
      // Calculer la r√©solution optimale bas√©e sur l'√©cran
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const aspectRatio = screenWidth / screenHeight;

      // Demander une r√©solution adapt√©e √† l'√©cran
      let videoConstraints: MediaTrackConstraints = {
        facingMode: 'user' // Cam√©ra frontale par d√©faut
      };

      // Adapter la r√©solution demand√©e √† l'√©cran
      if (aspectRatio > 1.5) {
        // √âcran large (16:9 ou plus)
        videoConstraints.width = { ideal: Math.min(1920, screenWidth * 0.9) };
        videoConstraints.height = { ideal: Math.min(1080, screenHeight * 0.9) };
      } else {
        // √âcran plus carr√©
        videoConstraints.width = { ideal: Math.min(1280, screenWidth * 0.9) };
        videoConstraints.height = { ideal: Math.min(720, screenHeight * 0.9) };
      }

      console.log('üìπ Demande de r√©solution cam√©ra:', videoConstraints);

      this.cameraStream = await navigator.mediaDevices.getUserMedia({
        video: videoConstraints,
        audio: false
      });

      this.cameraActive = true;
      this.cameraReady = false;
      this.showCameraModal = true;

      // Attendre que le DOM soit mis √† jour
      setTimeout(() => {
        const videoElement = document.getElementById('cameraVideo') as HTMLVideoElement;
        if (videoElement && this.cameraStream) {
          console.log('üìπ Configuration de l\'√©l√©ment vid√©o...');
          console.log('VideoElement trouv√©:', !!videoElement);
          console.log('CameraStream disponible:', !!this.cameraStream);

          // Forcer l'affichage de la vid√©o
          videoElement.style.display = 'block';
          videoElement.style.opacity = '1';
          videoElement.style.visibility = 'visible';
          videoElement.style.background = 'blue'; // Pour voir si l'√©l√©ment est visible

          videoElement.srcObject = this.cameraStream;

          // Attendre que les m√©tadonn√©es de la vid√©o soient charg√©es
          videoElement.onloadedmetadata = () => {
            console.log(`üìπ M√©tadonn√©es charg√©es: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
            console.log('üìπ ReadyState:', videoElement.readyState);
            console.log('üìπ Style computed:', window.getComputedStyle(videoElement).display);

            // Ajuster le container pour maintenir le ratio
            const container = videoElement.closest('.camera-container') as HTMLElement;
            if (container) {
              const ratio = videoElement.videoHeight / videoElement.videoWidth;
              container.style.aspectRatio = `${videoElement.videoWidth} / ${videoElement.videoHeight}`;
              console.log('üìπ Container aspect ratio d√©fini:', container.style.aspectRatio);
            }
          };

          // S'assurer que la vid√©o est bien en cours de lecture
          videoElement.oncanplay = () => {
            console.log('üìπ Vid√©o pr√™te pour la capture (canplay)');
            console.log('üìπ Video playing:', !videoElement.paused && !videoElement.ended && videoElement.readyState > 2);
            this.cameraReady = true;
          };

          videoElement.onloadeddata = () => {
            console.log('üìπ Donn√©es vid√©o charg√©es (loadeddata)');
            // Test si le stream est bien connect√©
            if (videoElement.srcObject === this.cameraStream) {
              console.log('‚úÖ Stream correctement assign√© √† la vid√©o');
            } else {
              console.error('‚ùå Stream non assign√© correctement');
              // R√©essayer d'assigner le stream
              videoElement.srcObject = this.cameraStream;
            }
          };

          videoElement.onplaying = () => {
            console.log('üìπ Vid√©o en cours de lecture (playing)');
          };

          videoElement.play().then(() => {
            console.log('üìπ Lecture vid√©o d√©marr√©e avec succ√®s');
            // Double v√©rification apr√®s 1 seconde
            setTimeout(() => {
              if (videoElement.readyState >= 2 && videoElement.videoWidth > 0) {
                this.cameraReady = true;
                console.log('üìπ Cam√©ra confirm√©e pr√™te');
                console.log('üìπ √âtat final - Paused:', videoElement.paused, 'Ended:', videoElement.ended, 'ReadyState:', videoElement.readyState);
              }
            }, 1000);
          }).catch(err => {
            console.error('‚ùå Erreur de lecture vid√©o:', err);
          });
        } else {
          console.error('‚ùå √âl√©ment vid√©o ou stream introuvable');
          console.log('VideoElement:', !!videoElement);
          console.log('CameraStream:', !!this.cameraStream);
        }
      }, 100);

      console.log('‚úÖ Cam√©ra d√©marr√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur d\'acc√®s √† la cam√©ra:', error);
      alert('Impossible d\'acc√©der √† la cam√©ra. V√©rifiez les permissions du navigateur.');
    }
  }

  async takeGroupPhoto(): Promise<void> {
    try {
      const videoElement = document.getElementById('cameraVideo') as HTMLVideoElement;

      if (!videoElement || !this.cameraStream) {
        console.error('√âl√©ments cam√©ra introuvables');
        return;
      }

      // V√©rifier que la vid√©o est bien en cours de lecture
      if (videoElement.readyState < 2) {
        console.error('Vid√©o pas encore pr√™te, readyState:', videoElement.readyState);
        alert('La cam√©ra n\'est pas encore pr√™te. Veuillez attendre quelques secondes et r√©essayer.');
        return;
      }

      // V√©rifier les dimensions de la vid√©o
      const videoWidth = videoElement.videoWidth;
      const videoHeight = videoElement.videoHeight;

      console.log(`üìπ Dimensions vid√©o: ${videoWidth}x${videoHeight}`);

      if (videoWidth === 0 || videoHeight === 0) {
        console.error('Dimensions vid√©o invalides');
        alert('Erreur: dimensions de la vid√©o invalides. Veuillez relancer la cam√©ra.');
        return;
      }

      // Cr√©er le canvas avec les bonnes dimensions
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        console.error('Impossible de cr√©er le contexte 2D');
        return;
      }

      // D√©finir les dimensions du canvas
      canvas.width = videoWidth;
      canvas.height = videoHeight;

      console.log(`üé® Canvas cr√©√©: ${canvas.width}x${canvas.height}`);

      // Capturer l'image de la vid√©o
      ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

      // V√©rifier que quelque chose a √©t√© captur√© (pixel test)
      const imageData = ctx.getImageData(0, 0, Math.min(10, canvas.width), Math.min(10, canvas.height));
      const hasContent = Array.from(imageData.data).some(value => value !== 0);

      if (!hasContent) {
        console.error('‚ö†Ô∏è Canvas semble vide, tentative avec d√©lai...');
        // Attendre un peu et r√©essayer
        await new Promise(resolve => setTimeout(resolve, 500));
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      }

      // Ajouter l'overlay "Promotion 2025"
      this.addPromotionOverlay(ctx, canvas.width, canvas.height);

      // T√©l√©charger l'image
      const link = document.createElement('a');
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0];
      link.download = `quiz-promotion-2025-${timestamp}.jpg`;

      // Utiliser une qualit√© plus √©lev√©e pour une meilleure image
      link.href = canvas.toDataURL('image/jpeg', 0.95);

      // D√©boguer: afficher la taille du dataURL
      console.log(`üì∏ Taille de l'image g√©n√©r√©e: ${link.href.length} caract√®res`);

      link.click();

      this.photoTaken = true;
      console.log('‚úÖ Photo de groupe prise avec succ√®s !');

      // Fermer la cam√©ra apr√®s 2 secondes
      setTimeout(() => {
        this.stopCamera();
      }, 2000);

    } catch (error) {
      console.error('‚ùå Erreur lors de la prise de photo:', error);
      alert('Erreur lors de la capture de la photo. Veuillez r√©essayer.');
    }
  }

  private addPromotionOverlay(ctx: CanvasRenderingContext2D, width: number, height: number): void {
    // Fond semi-transparent pour le texte
    ctx.fillStyle = 'rgba(35, 37, 38, 0.8)';
    ctx.fillRect(0, height - 100, width, 100);

    // Texte principal "Quiz Promotion 2025"
    ctx.fillStyle = '#f6d365';
    ctx.font = 'bold 32px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('üèÜ Quiz Promotion 2025', width / 2, height - 60);

    // Date
    const now = new Date();
    ctx.font = '18px Arial, sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(now.toLocaleDateString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }), width / 2, height - 25);

    // D√©coration coins
    ctx.fillStyle = '#DAE72A';
    ctx.font = '24px Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('üåü', 20, height - 40);
    ctx.textAlign = 'right';
    ctx.fillText('üåü', width - 20, height - 40);
  }

  stopCamera(): void {
    if (this.cameraStream) {
      // Arr√™ter tous les tracks de la cam√©ra
      this.cameraStream.getTracks().forEach(track => {
        track.stop();
      });
      this.cameraStream = null;
    }

    this.cameraActive = false;
    this.cameraReady = false;
    this.showCameraModal = false;
    this.photoTaken = false;
    console.log('‚úÖ Cam√©ra ferm√©e');
  }

  getCurrentDate(): string {
    return new Date().toLocaleDateString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }

  // ===== FIN M√âTHODES PHOTO DE GROUPE =====

  // M√©thode de capture graphique du leaderboard final
  async captureLeaderboard(): Promise<void> {
    try {
      // S√©lectionner un √©l√©ment plus large incluant le titre
      const element = document.querySelector('.container-question');
      if (!element) {
        console.error('√âl√©ment container-question introuvable pour la capture');
        return;
      }

      // Configuration html2canvas pour un rendu optimal
      const canvas = await html2canvas(element as HTMLElement, {
        backgroundColor: '#F1F1F1',
        scale: 2, // Haute r√©solution
        useCORS: true,
        allowTaint: false,
        width: (element as HTMLElement).offsetWidth,
        height: (element as HTMLElement).offsetHeight,
        scrollX: 0,
        scrollY: 0,
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        ignoreElements: (element) => {
          // Ignorer les boutons dans la capture
          return element.classList?.contains('step-final-buttons') || false;
        }
      });

      // Cr√©er un contexte pour ajouter des informations suppl√©mentaires
      const finalCanvas = document.createElement('canvas');
      const ctx = finalCanvas.getContext('2d');

      if (!ctx) return;

      // Dimensions du canvas final avec espace pour les m√©tadonn√©es
      const padding = 40;
      const headerHeight = 60;
      const footerHeight = 40;
      finalCanvas.width = canvas.width + (padding * 2);
      finalCanvas.height = canvas.height + headerHeight + footerHeight + (padding * 2);

      // Fond du canvas final
      ctx.fillStyle = '#F1F1F1';
      ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

      // Header avec titre
      ctx.fillStyle = '#232526';
      ctx.font = 'bold 28px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('üèÜ Quiz Application - Final Results', finalCanvas.width / 2, 35);

      // Ligne de s√©paration
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, headerHeight - 10);
      ctx.lineTo(finalCanvas.width - padding, headerHeight - 10);
      ctx.stroke();

      // Dessiner le leaderboard captur√©
      ctx.drawImage(canvas, padding, headerHeight + padding);

      // Footer avec date et heure
      const now = new Date();
      ctx.font = '14px Arial, sans-serif';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'center';
      ctx.fillText(`Generated on ${now.toLocaleString('fr-FR')}`, finalCanvas.width / 2, finalCanvas.height - 15);

      // T√©l√©charger l'image
      const link = document.createElement('a');
      const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0];
      link.download = `quiz-final-results-${timestamp}.png`;
      link.href = finalCanvas.toDataURL('image/png', 0.95);
      link.click();

      console.log('‚úÖ Capture du leaderboard r√©ussie !');
    } catch (error) {
      console.error('‚ùå Erreur lors de la capture:', error);
    }
  }

  // M√©thodes de gestion admin
  extendSession(): void {
    this.adminAuthService.extendSession();
  }

  logout(): void {
    if (confirm('√ätes-vous s√ªr de vouloir vous d√©connecter ?')) {
      this.adminAuthService.logout();
      this.router.navigate(['/admin-login']);
    }
  }

  getRemainingTime(): string {
    return this.adminAuthService.getFormattedRemainingTime();
  }

  // M√©thodes de restauration
  async onRestoreGame(): Promise<void> {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      await new Promise(resolve => setTimeout(resolve, this.minModalDisplayTime - elapsedTime));
    }

    try {
      console.log('üîÑ Tentative de restauration de la partie...');

      const restored = await this.quizService.restoreGameState();
      if (restored) {
        this.showRestoreDialog = false;

        // Synchroniser l'√©tat local avec l'√©tat restaur√©
        this.participants = this.quizService.participants;

        // R√©cup√©rer l'√©tape actuelle du serveur
        try {
          const gameState = await this.quizService.getGameState();
          this.step = gameState?.step || 'lobby';

          // Si on est dans une question, synchroniser le timer
          if (this.step === 'question') {
            console.log('üïê Restauration pendant une question, synchronisation du timer');
            await this.syncTimerWithServer();
          }

        } catch (error) {
          console.warn('Erreur lors de la r√©cup√©ration de l\'√©tape, utilisation de lobby par d√©faut');
          this.step = 'lobby';
        }

        console.log('‚úÖ Partie restaur√©e avec succ√®s !');

      } else {
        console.error('‚ùå Impossible de restaurer la partie');
        this.onStartNewGame();
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la restauration:', error);
      this.onStartNewGame();
    }
  }

  onStartNewGame(): void {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      setTimeout(() => {
        this.actuallyStartNewGame();
      }, this.minModalDisplayTime - elapsedTime);
    } else {
      this.actuallyStartNewGame();
    }
  }

  private actuallyStartNewGame(): void {
    console.log('üÜï D√©marrage d\'une nouvelle partie');
    this.showRestoreDialog = false;

    // Effacer la sauvegarde pr√©c√©dente
    this.quizService.clearSavedGameState();

    // Initialiser une nouvelle partie
    this.initializeNewGame();
  }

  /**
   * Force le rafra√Æchissement des participants depuis le serveur
   * Utilis√© quand on suspecte que la liste des participants n'est pas √† jour
   */
  public async refreshParticipants(): Promise<void> {
    try {
      console.log('[PRESENTATION] Rafra√Æchissement forc√© des participants...');
      
      // Stocker la liste actuelle pour pouvoir y revenir en cas de probl√®me
      const currentParticipants = [...this.participants];
      const currentCount = currentParticipants.length;
      
      // V√©rifier d'abord si nous avons des participants dans le cache local
      const cachedParticipantsStr = localStorage.getItem('presentation_participants_cache');
      let cachedParticipants: User[] = [];
      
      if (cachedParticipantsStr) {
        try {
          cachedParticipants = JSON.parse(cachedParticipantsStr);
          if (Array.isArray(cachedParticipants) && cachedParticipants.length > 0) {
            console.log(`[PRESENTATION] ${cachedParticipants.length} participants trouv√©s dans le cache local`);
            
            // Si notre liste actuelle est vide mais le cache contient des participants,
            // utiliser imm√©diatement le cache pour √©viter l'affichage vide
            if (currentCount === 0 && cachedParticipants.length > 0) {
              console.log(`[PRESENTATION] Utilisation imm√©diate du cache (${cachedParticipants.length} participants) car la liste actuelle est vide`);
              this.participants = cachedParticipants;
              this.cdr.detectChanges();
            }
          }
        } catch (cacheError) {
          console.warn('[PRESENTATION] Erreur lors de la lecture du cache des participants:', cacheError);
        }
      }
      
      // Faire jusqu'√† 5 tentatives en cas d'√©chec ou de liste vide inattendue (augment√© de 3 √† 5)
      const maxAttempts = 5;
      let participants: User[] = [];
      let successfulAttempt = false;
      
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        try {
          if (attempt > 0) {
            console.log(`[PRESENTATION] Tentative ${attempt + 1}/${maxAttempts} de r√©cup√©ration des participants...`);
            // D√©lai progressif entre les tentatives (500ms, 1000ms, 1500ms...)
            await new Promise(resolve => setTimeout(resolve, 500 * (attempt + 1)));
          }
          
          participants = await this.quizService.fetchParticipantsFromServer();
          
          // Si on r√©cup√®re des participants, sortir de la boucle
          if (participants && Array.isArray(participants) && participants.length > 0) {
            console.log(`[PRESENTATION] ${participants.length} participants r√©cup√©r√©s avec succ√®s √† la tentative ${attempt + 1}`);
            successfulAttempt = true;
            break;
          } else {
            console.warn(`[PRESENTATION] La tentative ${attempt + 1} a retourn√© une liste vide ou invalide`);
          }
        } catch (retryError) {
          console.warn(`[PRESENTATION] √âchec de la tentative ${attempt + 1}:`, retryError);
        }
      }
      
      // V√©rification et traitement des r√©sultats
      if (successfulAttempt && participants && Array.isArray(participants) && participants.length > 0) {
        // Nous avons re√ßu des participants valides du serveur
        this.participants = participants;
        console.log(`[PRESENTATION] Participants rafra√Æchis depuis le serveur: ${this.participants.length}`);
        
        // Mettre √† jour le cache local avec la nouvelle liste
        try {
          localStorage.setItem('presentation_participants_cache', JSON.stringify(this.participants));
          console.log('[PRESENTATION] Cache de participants mis √† jour avec la nouvelle liste');
        } catch (cacheError) {
          console.warn('[PRESENTATION] Impossible de mettre √† jour le cache des participants:', cacheError);
        }
        
        // Forcer la d√©tection des changements
        this.cdr.detectChanges();
        
        // Mettre √† jour le leaderboard √©galement
        this.updateLeaderboard();
      } else {
        // √âchec de r√©cup√©ration des participants depuis le serveur
        console.warn(`[PRESENTATION] √âchec de r√©cup√©ration des participants apr√®s ${maxAttempts} tentatives`);
        
        // Strat√©gie de fallback
        if (currentCount > 0) {
          // Conserver la liste existante si elle n'est pas vide
          console.log(`[PRESENTATION] Conservation de la liste existante (${currentCount} participants)`);
          
          // Mettre √† jour le cache si n√©cessaire
          if (currentCount > 0) {
            try {
              localStorage.setItem('presentation_participants_cache', JSON.stringify(currentParticipants));
              console.log('[PRESENTATION] Liste actuelle sauvegard√©e dans le cache local');
            } catch (cacheError) {
              console.warn('[PRESENTATION] Impossible de sauvegarder la liste actuelle dans le cache:', cacheError);
            }
          }
        } else if (cachedParticipants.length > 0) {
          // Si la liste actuelle est vide mais nous avons un cache, utiliser le cache
          console.log(`[PRESENTATION] Utilisation du cache (${cachedParticipants.length} participants) car √©chec de r√©cup√©ration depuis le serveur`);
          this.participants = cachedParticipants;
          this.cdr.detectChanges();
          this.updateLeaderboard();
        } else {
          // Aucune source de donn√©es disponible
          console.warn('[PRESENTATION] Aucune source de participants disponible (ni serveur, ni cache, ni liste actuelle)');
        }
      }
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors du rafra√Æchissement des participants:', error);
      // Essayer de restaurer depuis le cache local en cas d'erreur
      this.restoreParticipantsFromCache();
    }
  }
  
  /**
   * M√©thode pour restaurer les participants depuis le cache local
   * Utilis√©e en cas d'√©chec de r√©cup√©ration depuis le serveur
   */
  private restoreParticipantsFromCache(): void {
    try {
      console.log('[PRESENTATION] Tentative de restauration des participants depuis le cache local...');
      
      const cachedParticipantsStr = localStorage.getItem('presentation_participants_cache');
      if (!cachedParticipantsStr) {
        console.log('[PRESENTATION] Aucun cache de participants trouv√©');
        return;
      }
      
      const parsedParticipants = JSON.parse(cachedParticipantsStr) as User[];
      if (!Array.isArray(parsedParticipants)) {
        console.warn('[PRESENTATION] Format de cache invalide, ce n\'est pas un tableau');
        return;
      }
      
      if (parsedParticipants.length === 0) {
        console.log('[PRESENTATION] Le cache contient une liste vide de participants');
        return;
      }
      
      // Strat√©gie de restauration am√©lior√©e:
      // 1. Si la liste actuelle est vide, toujours utiliser le cache
      // 2. Si le cache contient plus de participants que la liste actuelle, utiliser le cache
      // 3. Si les deux listes ont le m√™me nombre d'√©l√©ments mais > 0, v√©rifier si ce sont les m√™mes participants
      
      const currentCount = this.participants.length;
      const cacheCount = parsedParticipants.length;
      
      if (currentCount === 0) {
        // Cas 1: Liste actuelle vide, toujours restaurer depuis le cache
        console.log(`[PRESENTATION] Restauration de ${cacheCount} participants depuis le cache (liste actuelle vide)`);
        this.participants = [...parsedParticipants];
        this.cdr.detectChanges();
        this.updateLeaderboard();
        return;
      }
      
      if (cacheCount > currentCount) {
        // Cas 2: Cache contient plus de participants
        console.log(`[PRESENTATION] Restauration de ${cacheCount} participants depuis le cache (${cacheCount} > ${currentCount})`);
        this.participants = [...parsedParticipants];
        this.cdr.detectChanges();
        this.updateLeaderboard();
        return;
      }
      
      if (cacheCount === currentCount && cacheCount > 0) {
        // Cas 3: V√©rifier si ce sont les m√™mes participants
        // Si les deux listes sont identiques, pas besoin de remplacer
        // Pour simplifier, on v√©rifie juste quelques IDs au lieu de comparer toute la liste
        const sampleSize = Math.min(3, cacheCount);
        let isDifferent = false;
        
        for (let i = 0; i < sampleSize; i++) {
          if (this.participants[i].id !== parsedParticipants[i].id) {
            isDifferent = true;
            break;
          }
        }
        
        if (isDifferent) {
          console.log(`[PRESENTATION] Les listes actuelles et en cache sont diff√©rentes mais de m√™me taille, conservation des deux`);
          // On pourrait fusionner les listes, mais pour l'instant on garde la liste actuelle
        } else {
          console.log(`[PRESENTATION] Les listes actuelles et en cache semblent identiques, aucune action n√©cessaire`);
        }
        return;
      }
      
      console.log(`[PRESENTATION] Le cache contient moins de participants (${cacheCount}) que la liste actuelle (${currentCount}), conservation de la liste actuelle`);
      
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors de la restauration des participants depuis le cache:', error);
    }
  }

  /**
   * Synchronise l'√©tat local avec l'√©tat du serveur
   */
  private async synchronizeWithServer(serverState: any): Promise<void> {
    try {
      console.log('üîÑ Synchronisation avec l\'√©tat du serveur:', serverState);

      // Initialiser les composants de base
      this.quizService.initQuestions();

      // Synchroniser l'√©tape
      this.step = serverState.step || 'lobby';

      // Initialiser les souscriptions avec force pour s'assurer de la synchronisation
      this.initializeSubscriptions(true);

      // R√©cup√©ration des participants en plusieurs √©tapes pour maximiser les chances de succ√®s
      
      // √âTAPE 1: V√©rifier d'abord le cache local
      console.log('[PRESENTATION] √âTAPE 1: V√©rification du cache local des participants...');
      const cachedParticipantsStr = localStorage.getItem('presentation_participants_cache');
      let cachedList: User[] = [];
      
      if (cachedParticipantsStr) {
        try {
          cachedList = JSON.parse(cachedParticipantsStr) as User[];
          if (Array.isArray(cachedList) && cachedList.length > 0) {
            console.log(`[PRESENTATION] ${cachedList.length} participants trouv√©s dans le cache local`);
            // Pr√©-remplir la liste des participants avec le cache pour √©viter l'√©cran vide
            this.participants = [...cachedList];
            this.cdr.detectChanges();
          }
        } catch (cacheError) {
          console.warn('[PRESENTATION] Erreur lors de la lecture du cache:', cacheError);
        }
      } else {
        console.log('[PRESENTATION] Aucun cache local trouv√©');
      }

      // √âTAPE 2: R√©cup√©rer la liste des participants directement depuis le serveur (premi√®re tentative)
      console.log('[PRESENTATION] √âTAPE 2: R√©cup√©ration directe des participants depuis le serveur...');
      let serverParticipants: User[] = [];
      
      try {
        serverParticipants = await this.quizService.fetchParticipantsFromServer();
        
        if (serverParticipants && Array.isArray(serverParticipants) && serverParticipants.length > 0) {
          console.log(`[PRESENTATION] ${serverParticipants.length} participants r√©cup√©r√©s directement du serveur`);
          
          // Ne remplacer que si le serveur retourne une liste non vide
          // ou si nous n'avions pas d√©j√† une liste en cache
          if (serverParticipants.length > 0) {
            this.participants = serverParticipants;
            this.cdr.detectChanges();
            
            // Mettre √† jour le cache avec la liste fra√Æchement r√©cup√©r√©e
            try {
              localStorage.setItem('presentation_participants_cache', JSON.stringify(serverParticipants));
              console.log('[PRESENTATION] Cache mis √† jour avec les participants du serveur');
            } catch (cacheError) {
              console.warn('[PRESENTATION] Erreur lors de la mise √† jour du cache:', cacheError);
            }
          } else if (this.participants.length === 0) {
            // La liste du serveur est vide et nous n'avions pas de liste pr√©c√©dente
            console.log('[PRESENTATION] Le serveur a retourn√© une liste vide et aucun cache n\'est disponible');
          }
        } else if (serverParticipants && Array.isArray(serverParticipants) && serverParticipants.length === 0) {
          // Le serveur a retourn√© une liste vide
          console.log('[PRESENTATION] Le serveur a retourn√© une liste vide de participants');
          
          // Si nous avons une liste en cache et que la liste serveur est vide, conserver le cache
          if (cachedList.length > 0) {
            console.log(`[PRESENTATION] Conservation des ${cachedList.length} participants du cache (le serveur a retourn√© une liste vide)`);
          }
        }
      } catch (error) {
        console.warn('[PRESENTATION] Erreur lors de la r√©cup√©ration directe depuis le serveur:', error);
      }

      // √âTAPE 3: Utiliser notre m√©thode optimis√©e de rafra√Æchissement qui inclut plusieurs tentatives
      console.log('[PRESENTATION] √âTAPE 3: Utilisation de la m√©thode optimis√©e refreshParticipants...');
      try {
        await this.refreshParticipants();
        console.log('üë• Participants synchronis√©s via refreshParticipants:', this.participants.length);
      } catch (error) {
        console.warn('‚ö†Ô∏è √âchec de refreshParticipants:', error);
        
        // Si toutes les tentatives ont √©chou√© et que nous n'avons toujours pas de participants
        if (this.participants.length === 0 && cachedList.length > 0) {
          console.log(`[PRESENTATION] Dernier recours: utilisation des ${cachedList.length} participants du cache apr√®s √©checs multiples`);
          this.participants = cachedList;
          this.cdr.detectChanges();
        }
      }

      // Si on est dans une question, synchroniser l'index et le timer
      if (serverState.step === 'question') {
        this.currentIndex = serverState.currentQuestionIndex || 0;
        this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

        // Synchroniser le timer si n√©cessaire
        if (serverState.questionStartTime && serverState.questionStartTime > 0) {
          // Timer d√©j√† d√©marr√© sur le serveur, marquer comme d√©marr√© manuellement
          this.timerStartedManually = true;
          console.log('[SYNC] Timer d√©j√† d√©marr√© c√¥t√© serveur, timerStartedManually = true');
          this.checkAndSyncTimer();
        } else {
          // Timer pas encore d√©marr√©, rester en attente
          this.timerStartedManually = false;
          console.log('[SYNC] Timer pas encore d√©marr√© c√¥t√© serveur, timerStartedManually = false');
        }
      }

      // Si on est dans les r√©sultats, synchroniser l'index de la question
      if (serverState.step === 'result') {
        this.currentIndex = serverState.currentQuestionIndex || 0;
        this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);
      }

      // Forcer la mise √† jour du leaderboard
      this.updateLeaderboard();

      // Forcer la d√©tection des changements
      this.cdr.detectChanges();

      console.log('‚úÖ Synchronisation termin√©e:', {
        step: this.step,
        currentIndex: this.currentIndex,
        participants: this.participants.length
      });

    } catch (error) {
      console.error('‚ùå Erreur lors de la synchronisation:', error);
      // M√™me en cas d'erreur, essayer de restaurer depuis le cache
      this.restoreParticipantsFromCache();
    }
  }

  // Syst√®me de loading pour synchroniser avec les joueurs
  private showLoadingForTransition(type: string) {
    this.isLoading = true;
    this.loadingType = type;
    this.loadingMessage = this.getLoadingMessage(type);
    console.log('[PRESENTATION][LOADING] Transition:', type, 'Message:', this.loadingMessage);
  }

  private getLoadingMessage(type: string): string {
    switch (type) {
      case 'question-start': return 'Synchronisation...';
      case 'question-result': return 'R√©sultats...';
      case 'next-question': return 'Pr√©paration...';
      case 'quiz-end': return 'Termin√© !';
      default: return 'Synchronisation...';
    }
  }

  // Intervalle de rafra√Æchissement des participants en phase lobby
  private lobbyRefreshInterval?: any;
  
  // Gestion des actions sp√©cifiques aux √©tapes pour la pr√©sentation
  private handleStepActivationPresentation(step: QuizStep) {
    console.log('[PRESENTATION][STEP-ACTIVATION] Traitement de l\'√©tape:', step);

    // Nettoyer l'intervalle existant quelle que soit l'√©tape
    if (this.lobbyRefreshInterval) {
      clearInterval(this.lobbyRefreshInterval);
      this.lobbyRefreshInterval = undefined;
    }

    if (step === 'question') {
      // R√©initialiser le flag de d√©marrage manuel pour chaque nouvelle question
      this.timerStartedManually = false;
      // Ne plus d√©marrer automatiquement le timer - attendre le d√©marrage manuel
      console.log('[MANUAL-TIMER] Question affich√©e, en attente de d√©marrage manuel du timer');
    } else if (step === 'result' || step === 'end') {
      // Pour les √©tapes r√©sultat et fin, on force un rafra√Æchissement imm√©diat et plusieurs suivis
      console.log('[PRESENTATION] Passage √† l\'√©tape ' + step + ' - For√ßage du rafra√Æchissement du leaderboard');
      this.forceLeaderboardUpdate('changement √©tape vers ' + step);
      
      // Programmer des rafra√Æchissements successifs pour s'assurer de la prise en compte
      const refreshTimes = [500, 1000, 2000];
      refreshTimes.forEach(delay => {
        setTimeout(() => {
          this.forceLeaderboardUpdate(`suivi apr√®s ${delay}ms - √©tape ${step}`);
        }, delay);
      });
      
      this.stopTimer();
      this.timerStartedManually = false;
    } else {
      this.stopTimer();
      this.timerStartedManually = false;
    }
    
    // Gestion sp√©cifique des mises √† jour du leaderboard selon les √©tapes
    if (step === 'result') {
      // CORRECTION MAJEURE: Force une s√©rie de mises √† jour pour l'√©tape r√©sultat
      const updateTimes = [100, 500, 1500, 3000];
      updateTimes.forEach(delay => {
        setTimeout(() => {
          // Mise √† jour programm√©e des scores - √âtape r√©sultat
          this.forceLeaderboardUpdate(`√©tape r√©sultat apr√®s ${delay}ms`);
        }, delay);
      });
    } else if (step === 'end') {
      // CORRECTION MAJEURE: Force une s√©rie de mises √† jour pour l'√©tape finale
      const updateTimes = [100, 500, 1500, 3000];
      updateTimes.forEach(delay => {
        setTimeout(() => {
          // Mise √† jour programm√©e des scores - √âtape finale
          this.forceLeaderboardUpdate(`√©tape finale apr√®s ${delay}ms`);
        }, delay);
      });
    }
    
    // Actions sp√©cifiques √† l'√©tape lobby
    if (step === 'lobby') {
      // R√©initialisation des r√©ponses
      this.quizService.resetAllAnswers();
      
      // Rafra√Æchir imm√©diatement la liste des participants
      this.refreshParticipants();
      
      // Mettre en place un intervalle pour rafra√Æchir r√©guli√®rement la liste des participants en phase lobby
      // Utiliser un d√©lai plus long (10 secondes) pour √©viter les rafra√Æchissements trop fr√©quents
      // qui pourraient causer des probl√®mes de synchronisation et des r√©initialisations inutiles
      this.lobbyRefreshInterval = setInterval(() => {
        this.refreshParticipants();
      }, 10000); // Rafra√Æchir toutes les 10 secondes au lieu de 5
      
      console.log('[PRESENTATION] Intervalle de rafra√Æchissement des participants activ√© pour la phase lobby (10s)');
    }
  }

  // D√©marrage manuel du timer (synchronis√© avec tous les clients via WebSocket)
  async startTimerManually(duration: number = 20) {
    console.log('[MANUAL-TIMER] D√©marrage manuel du timer pour', duration, 'secondes');

    try {
      const response = await fetch(`${this.apiUrl}/start-timer`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          duration: duration,
          currentQuestionIndex: this.currentIndex
        })
      });

      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }

      const result = await response.json();
      console.log('[MANUAL-TIMER] Timer d√©marr√© avec succ√®s:', result);

      this.timerStartedManually = true;

    } catch (error) {
      console.error('[MANUAL-TIMER] Erreur lors du d√©marrage du timer:', error);
      // Fallback: d√©marrer localement si le serveur ne r√©pond pas
      this.timerStartedManually = true;
    }
  }
}
