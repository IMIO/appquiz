
import { Component, ChangeDetectorRef, OnInit, OnDestroy } from '@angular/core';
import { TimerService, TimerState } from '../services/timer.service';
import { CommonModule } from '@angular/common';
import { QuizService, QuizStep } from '../services/quiz-secure.service';
import { Question } from '../models/question.model';
import { User } from '../models/user.model';
import { Observable, timer, Subscription, firstValueFrom } from 'rxjs';
import { LeaderboardEntry } from '../models/leaderboard-entry.model';
import { trigger, state, style, transition, animate, query, stagger } from '@angular/animations';
import html2canvas from 'html2canvas';
import { QRCodeComponent } from 'angularx-qrcode';
import { AdminAuthService } from '../services/admin-auth.service';
import { Router } from '@angular/router';
import { WebSocketTimerService } from '../services/websocket-timer.service';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { DebugPanelComponent } from '../debug-panel/debug-panel.component';
import { setupImageDebug } from '../debug-image';
import { generateLeaderboardDiagnostic, checkAnswersQuestionsSynchronization } from '../debug-leaderboard';
import { LeaderboardSyncComponent } from '../leaderboard-sync/leaderboard-sync.component';
import { fetchAllAnswersDirectly } from '../direct-fetch-answers';

@Component({
  selector: 'app-presentation',
  standalone: true,
  imports: [CommonModule, QRCodeComponent, DebugPanelComponent, LeaderboardSyncComponent],
  templateUrl: './presentation.component.html',
  styleUrls: ['./presentation.component.css'],
  animations: [
    // Animation pour les transitions d'√©tapes
    trigger('stepTransition', [
      transition(':enter', [
        style({ opacity: 0, transform: 'translateY(30px)' }),
        animate('500ms cubic-bezier(0.4, 0, 0.2, 1)',
          style({ opacity: 1, transform: 'translateY(0)' }))
      ])
    ]),

    // Animation pour les √©l√©ments de liste
    trigger('listAnimation', [
      transition('* => *', [
        query(':enter', [
          style({ opacity: 0, transform: 'translateY(20px)' }),
          stagger(100, [
            animate('400ms cubic-bezier(0.4, 0, 0.2, 1)',
              style({ opacity: 1, transform: 'translateY(0)' }))
          ])
        ], { optional: true })
      ])
    ]),

    // Animation pour les images
    trigger('imageAnimation', [
      transition(':enter', [
        style({ opacity: 0, transform: 'scale(0.9)' }),
        animate('400ms cubic-bezier(0.4, 0, 0.2, 1)',
          style({ opacity: 1, transform: 'scale(1)' }))
      ])
    ])
  ]
})
export class PresentationComponent implements OnInit, OnDestroy {
  getImageUrl(url: string | undefined): string {
    if (!url) return '';
    if (url.startsWith('http')) return url;
    // Si c'est un asset statique (dans /assets ou favicon), retourner l'URL telle quelle
    if (url.startsWith('/assets') || url.startsWith('assets') || url.startsWith('/favicon.ico')) {
      return url;
    }
    // Sinon, pr√©fixer par l'API (pour images upload√©es/dynamiques)
    const apiBase = this.apiUrl.replace(/\/api$/, '');
    return `${apiBase}${url}`;
  }
  step: any = 'lobby'; // Typage √©largi pour compatibilit√© template Angular
  showRestoreDialog: boolean = false;
  private minModalDisplayTime = 2000; // Afficher le modal au minimum 2 secondes
  private modalStartTime = 0;
  buttonsEnabled = false;

  async ngOnInit() {
    // D√©marrer un intervalle de rafra√Æchissement des participants toutes les 5 secondes
    this.participantsRefreshInterval = setInterval(() => {
      this.checkParticipantsDirectly();
    }, 5000);
    
    // D'abord, synchroniser avec l'√©tat du serveur
    try {
      const serverState = await this.quizService.getGameState();
      // Si le serveur n'est pas √† l'√©tape lobby, il faut restaurer cet √©tat
      if (serverState && serverState.step && serverState.step !== 'lobby') {
        await this.synchronizeWithServer(serverState);
        return;
      }
      // V√©rifier s'il y a un √©tat sauvegard√© √† restaurer
      if (this.quizService.canRestoreGameState()) {
        this.showRestoreDialog = true;
        this.modalStartTime = Date.now();
        this.buttonsEnabled = false;
        setTimeout(() => {
          this.buttonsEnabled = true;
        }, this.minModalDisplayTime);
        // NE PAS initialiser tant que l'utilisateur n'a pas choisi
        return;
      }
      // Initialisation pour une nouvelle partie
      this.initializeNewGame();
    } catch (error) {
      // En cas d'erreur, continuer avec l'initialisation normale
      this.initializeNewGame();
    }
  }

  private async initializeNewGame() {
    await this.quizService.initQuestions();
    this.step = 'lobby';
    this.quizService.setStep('lobby');
    this.quizService.initGameState();
    try {
      await this.quizService.fetchParticipantsFromServer();
    } catch (error) {}
    this.initializeSubscriptions();
  }

  // M√©thode pour synchroniser avec les modifications c√¥t√© gestion
  async synchronizeWithManagement(): Promise<void> {
    console.log('[PRESENTATION] Synchronisation avec les modifications c√¥t√© gestion...');

    // D√©marrer l'√©tat de synchronisation
    this.isSynchronizing = true;
    this.synchronizationSuccess = false;
    this.synchronizationMessage = 'Synchronisation en cours...';

    try {
      // √âtape 1: Synchroniser les questions et reset les donn√©es
      this.synchronizationMessage = 'Rechargement des questions...';
      await this.quizService.synchronizeAfterChanges();

      // √âtape 2: D√©clencher la synchronisation c√¥t√© joueur via WebSocket
      this.synchronizationMessage = 'Notification des joueurs...';
      await this.triggerPlayerQuestionsSync();

      // √âtape 3: R√©initialiser l'√©tat local
      this.synchronizationMessage = 'R√©initialisation de l\'√©tat local...';
      await new Promise(resolve => setTimeout(resolve, 500)); // D√©lai pour l'UX

      this.currentIndex = 0;
      this.currentQuestion = this.quizService.getCurrentQuestion(0);
      this.leaderboard = [];
      this.questionStartTimes = {};
      this.goodAnswersTimesByUser = {};

      // √âtape 4: Retourner au lobby
      this.synchronizationMessage = 'Retour au lobby...';
      this.step = 'lobby';
      this.quizService.setStep('lobby');

      // Succ√®s
      this.synchronizationMessage = '‚úÖ Synchronisation termin√©e avec succ√®s !';
      this.synchronizationSuccess = true;

      console.log('[PRESENTATION] Synchronisation termin√©e, retour au lobby');

      // Masquer le message de succ√®s apr√®s 3 secondes
      setTimeout(() => {
        this.isSynchronizing = false;
        this.synchronizationMessage = '';
        this.synchronizationSuccess = false;
      }, 3000);

    } catch (error) {
      console.error('[PRESENTATION] Erreur lors de la synchronisation:', error);

      // Affichage d'erreur
      this.synchronizationMessage = '‚ùå Erreur lors de la synchronisation';
      this.synchronizationSuccess = false;

      // Masquer le message d'erreur apr√®s 5 secondes
      setTimeout(() => {
        this.isSynchronizing = false;
        this.synchronizationMessage = '';
      }, 5000);
    }
  }

  // M√©thode pour d√©clencher la synchronisation des questions c√¥t√© joueur
  private async triggerPlayerQuestionsSync(): Promise<void> {
    try {
      console.log('[PRESENTATION] D√©clenchement sync questions via WebSocket...');
      console.log('[PRESENTATION] URL appel√©e:', `${this.apiUrl}/quiz/sync-questions`);

      const response = await firstValueFrom(
        this.http.post<any>(`${this.apiUrl}/quiz/sync-questions`, {})
      );

      console.log('[PRESENTATION] R√©ponse serveur sync questions:', response);

      if (response?.success) {
        console.log('[PRESENTATION] Sync questions WebSocket d√©clench√©e avec succ√®s');
      } else {
        console.warn('[PRESENTATION] R√©ponse inattendue du serveur pour sync questions:', response);
      }

    } catch (error) {
      console.error('[PRESENTATION] Erreur lors du d√©clenchement sync questions:', error);
      // Ne pas faire √©chouer toute la synchronisation pour cette erreur
    }
  }

  ngOnDestroy() {
    // Nettoyage des souscriptions pour √©viter les fuites m√©moire
    this.subscriptions.forEach(sub => sub.unsubscribe());
    this.subscriptions = [];

    // Nettoyage des autres souscriptions
    if (this.answersCountSub) {
      this.answersCountSub.unsubscribe();
    }
    if (this.timerSub) {
      this.timerSub.unsubscribe();
    }

    // Nettoyage de l'intervalle de diagnostic
    if (this.diagnosticInterval) {
      clearInterval(this.diagnosticInterval);
    }
    
    // Nettoyage de l'intervalle de rafra√Æchissement des participants
    if (this.participantsRefreshInterval) {
      clearInterval(this.participantsRefreshInterval);
    }
  }
  participants: User[] = [];
  currentIndex: number = 0;
  currentQuestion: Question | null = null;
  answersCount: number[] = [];
  answersCountSub?: Subscription;
  leaderboard: LeaderboardEntry[] = [];
  // Pour le d√©partage par vitesse de r√©ponse
  questionStartTimes: { [key: string]: number } = {};
  // Stocke le temps de chaque bonne r√©ponse par participant (cl√©: userId, valeur: tableau des temps)
  goodAnswersTimesByUser: { [userId: string]: number[] } = {};

  // Gestion des souscriptions pour √©viter les fuites m√©moire
  private subscriptions: Subscription[] = [];

  // Syst√®me de loading pour synchroniser avec les joueurs
  isLoading: boolean = false;
  loadingMessage: string = '';
  loadingType: string = '';

  // Flag pour √©viter les logs excessifs
  private debugMode = false;

  // R√©f√©rence pour l'intervalle de diagnostic
  private diagnosticInterval?: any;
  
  // R√©f√©rence pour l'intervalle de rafra√Æchissement des participants
  private participantsRefreshInterval?: any;

  // Gestion des images pour √©viter le flash
  imageLoaded: boolean = false;
  resultImageLoaded: boolean = true; // Initialiser √† true par d√©faut pour √©viter que l'image ne disparaisse
  // Flag pour forcer la disparition imm√©diate des images
  hideImages: boolean = false;

  // Retourne le temps total des bonnes r√©ponses pour un user
  // (m√©thode unique, suppression du doublon)
  windowLocation = window.location.origin;
  timerValue: number = 20;
  timerMax: number = 20; // Dur√©e du timer en secondes, synchronis√©e avec timerValue
  timerActive: boolean = false; // √âtat d'activation du timer pour l'affichage visuel

  // Contr√¥le manuel du timer
  timerStartedManually: boolean = false;

  // √âtat de synchronisation des questions
  isSynchronizing: boolean = false;
  synchronizationMessage: string = '';
  synchronizationSuccess: boolean = false;

  // Propri√©t√©s pour la photo de groupe
  cameraStream: MediaStream | null = null;
  cameraActive: boolean = false;
  cameraReady: boolean = false;
  showCameraModal: boolean = false;
  photoTaken: boolean = false;
  timerSub?: Subscription;
  totalAnswers: number = 0;
  totalGood: number = 0;
  totalBad: number = 0;
  voters: {id: any, name: any}[] = [];

  // Affichage temps format√© (mm:ss si > 60s, sinon ss.s)
  public formatTime(ms: number): string {
    if (!ms || ms < 0) return '';
    const totalSeconds = Math.floor(ms / 1000);
    if (totalSeconds < 60) {
      return (ms / 1000).toFixed(2) + ' s';
    } else {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      // Affichage sans centi√®mes pour plus de lisibilit√©
      return `${minutes} min ${seconds.toString().padStart(2, '0')} s`;
    }
  }

  canShowEndButton(): boolean {
    return this.currentIndex === (this.quizService.getQuestions().length - 1) && this.step !== 'end';
  }

  get totalQuestions(): number {
    return this.quizService.getQuestions().length;
  }

  getTotalQuestions(): number {
    return this.totalQuestions;
  }

  get currentQuestionNumber(): string {
    const questionNum = (this.currentIndex + 1).toString().padStart(2, '0');
    const totalQuestions = this.totalQuestions.toString().padStart(2, '0');
    return `${questionNum} sur ${totalQuestions}`;
  }
  
  // M√©thodes pour les scores utilisateurs avec validation robuste et logs de diagnostic
  getUserScore(user: any): number {
    // V√©rifications compl√®tes pour √©viter les valeurs NaN ou undefined
    if (!user) {
      console.warn('[SCORE] ‚ö†Ô∏è Tentative d\'acc√®s au score d\'un utilisateur null');
      return 0;
    }
    
    // V√©rifier si l'utilisateur a un score d√©fini
    if (user.score === undefined || user.score === null) {
      console.warn(`[SCORE] ‚ö†Ô∏è L'utilisateur ${user.name || 'inconnu'} (ID: ${user.id || 'inconnu'}) n'a pas de score d√©fini`);
      return 0;
    }
    
    // Normaliser le score en nombre
    const score = Number(user.score);
    
    // V√©rifier si le score est un nombre valide
    if (isNaN(score)) {
      console.warn(`[SCORE] ‚ö†Ô∏è Score invalide pour l'utilisateur ${user.name || 'inconnu'} (ID: ${user.id || 'inconnu'}): ${user.score} -> NaN`);
      return 0;
    }
    
    // Si le score est valide mais diff√©rent de l'original, log pour diagnostic
    if (score !== user.score) {
      console.log(`[SCORE] üîÑ Score normalis√© pour ${user.name || 'inconnu'}: ${user.score} -> ${score}`);
    }
    
    return score;
  }
  
  // M√©thode pour d√©tecter si le score a chang√©
  hasScoreChanged(userId: string): boolean {
    // √Ä compl√©ter selon la logique de votre application
    return false;
  }
  
  // Nouvelle m√©thode pour r√©cup√©rer les r√©ponses directement depuis l'API
  async fetchAllAnswersDirectlyFromAPI(): Promise<void> {
    try {
      console.log('[DIRECT-FETCH] üöÄ D√©marrage de la r√©cup√©ration directe des r√©ponses');
      
      // R√©cup√©rer les questions actuelles
      const questions = this.quizService.getQuestions();
      
      if (!questions || questions.length === 0) {
        console.warn('[DIRECT-FETCH] ‚ö†Ô∏è Aucune question disponible');
        return;
      }
      
      // Utiliser notre nouvelle fonction utilitaire pour r√©cup√©rer toutes les r√©ponses
      const answersDocs = await fetchAllAnswersDirectly(this.apiUrl, questions);
      
      console.log('[DIRECT-FETCH] üìä R√©ponses r√©cup√©r√©es directement:', answersDocs);
      
      // Utiliser ces r√©ponses pour recalculer le leaderboard
      this.calculateLeaderboardFromDirectAnswers(answersDocs);
      
    } catch (error) {
      console.error('[DIRECT-FETCH] ‚ùå Erreur lors de la r√©cup√©ration directe des r√©ponses:', error);
    }
  }
  
  // Calcule le leaderboard √† partir des r√©ponses r√©cup√©r√©es directement
  private calculateLeaderboardFromDirectAnswers(answersDocs: any[]): void {
    if (!this.participants || this.participants.length === 0) {
      console.warn('[DIRECT-FETCH] ‚ö†Ô∏è Aucun participant disponible pour calculer le leaderboard');
      return;
    }
    
    console.log('[DIRECT-FETCH] üë• Calcul du leaderboard pour', this.participants.length, 'participants');
    
    // R√©cup√©rer les questions pour obtenir les indices corrects
    const questions = this.quizService.getQuestions();
    
    // Mapping des IDs de questions aux indices corrects
    const questionIdToCorrectIndex = new Map<number, number>();
    questions.forEach(q => {
      if (q && q.id !== undefined && q.correctIndex !== undefined) {
        questionIdToCorrectIndex.set(q.id, q.correctIndex);
        console.log(`[DIRECT-FETCH] üìù Question ID=${q.id}, correctIndex=${q.correctIndex}`);
      }
    });
    
    // Calculer le score pour chaque participant
    const leaderboard: LeaderboardEntry[] = this.participants.map(user => {
      let score = 0;
      let totalTime = 0;
      let goodTimes: number[] = [];
      let currentQuestionCorrect = false;
      
      // Pour chaque r√©ponse r√©cup√©r√©e
      for (const doc of answersDocs) {
        const questionId = doc.questionId;
        const questionIndex = doc.index;
        const answers = doc.answers || [];
        
        // Trouver la r√©ponse de l'utilisateur actuel
        const userAnswer = answers.find((a: any) => String(a.userId) === String(user.id));
        
        if (userAnswer) {
          // R√©cup√©rer l'index correct pour cette question
          const correctIndex = questionIdToCorrectIndex.get(questionId);
          
          if (correctIndex !== undefined) {
            // Normaliser la r√©ponse de l'utilisateur
            const userAnswerIndex = typeof userAnswer.answerIndex === 'string' ? 
                                    parseInt(userAnswer.answerIndex) : Number(userAnswer.answerIndex);
                                    
            // V√©rifier si la r√©ponse est correcte
            const isCorrect = !isNaN(userAnswerIndex) && userAnswerIndex === correctIndex;
            
            // Log d√©taill√©
            console.log(`[DIRECT-FETCH] üßÆ ${user.name} - Q${questionIndex} (ID=${questionId}): ` +
                        `r√©ponse=${userAnswerIndex}, correcte=${correctIndex}, correct=${isCorrect}`);
            
            if (isCorrect) {
              // Incr√©menter le score
              score++;
              
              // Si c'est la question actuelle, marquer comme correcte
              if (questionIndex === this.currentIndex) {
                currentQuestionCorrect = true;
              }
              
              // Calculer le temps de r√©ponse
              if (userAnswer.timestamp && doc.questionStartTime) {
                const timeTaken = Math.min(userAnswer.timestamp - doc.questionStartTime, 20000); // Max 20s
                goodTimes[questionIndex] = timeTaken;
                totalTime += timeTaken;
              } else {
                // Si pas de timestamp, valeur par d√©faut
                goodTimes[questionIndex] = 15000; // 15 secondes par d√©faut
                totalTime += 15000;
              }
            } else {
              // R√©ponse incorrecte
              goodTimes[questionIndex] = undefined as any;
            }
          }
        }
      }
      
      // Enregistrer les temps pour ce participant
      this.goodAnswersTimesByUser[user.id] = goodTimes;
      
      return {
        id: user.id,
        name: user.name,
        avatarUrl: user.avatarUrl,
        score,
        totalTime,
        currentQuestionCorrect
      };
    });
    
    // Trier le leaderboard par score puis par temps
    this.leaderboard = leaderboard.sort((a, b) => {
      // Tri principal par score (d√©croissant)
      if (b.score !== a.score) return b.score - a.score;
      
      // Tri secondaire par temps (croissant = meilleur)
      return a.totalTime - b.totalTime;
    });
    
    // Log du r√©sultat
    console.log('[DIRECT-FETCH] üèÜ Leaderboard calcul√© avec', this.leaderboard.length, 'entr√©es');
    if (this.leaderboard.length > 0) {
      console.log('[DIRECT-FETCH] ü•á Premier:', this.leaderboard[0].name, 
                  `(${this.leaderboard[0].score}pts, ${this.formatTime(this.leaderboard[0].totalTime)})`);
    }
    
    // Forcer la mise √† jour de l'interface
    this.cdr.detectChanges();
  }
  
  // M√©thode utilis√©e dans le template pour forcer la mise √† jour du leaderboard avec diagnostic
  forceRefreshLeaderboard(): void {
    console.log("üîÑ [DEBUG] Force refresh leaderboard");
    
    // Activer temporairement le mode debug
    const oldDebugMode = this.debugMode;
    this.debugMode = true;
    
    // Utiliser d'abord la m√©thode de r√©cup√©ration directe
    this.fetchAllAnswersDirectlyFromAPI().then(() => {
      console.log("üîÑ [DEBUG] R√©cup√©ration directe termin√©e, refresh standard en cours...");
      
      // Puis effectuer la mise √† jour standard pour comparer les r√©sultats
      this.refreshLeaderboardWithDiagnostic(true);
      
      // Restaurer le mode debug apr√®s un d√©lai
      setTimeout(() => {
        this.debugMode = oldDebugMode;
      }, 5000);
    });
  }
  
  // Nouvelle m√©thode r√©utilisable pour rafra√Æchir le leaderboard
  // showDiagnostic: si true, affiche un diagnostic complet (pour le d√©bogage)
  refreshLeaderboardWithDiagnostic(showDiagnostic: boolean = false): void {
    // Afficher les informations sur les questions si diagnostic demand√©
    if (showDiagnostic) {
      const questions = this.quizService.getQuestions();
      console.log('üìä [DEBUG] Questions charg√©es:', questions.length);
      questions.forEach((q, idx) => {
        console.log(`üìù [DEBUG] Q${idx}: ID=${q.id}, R√©ponse correcte: ${q.correctIndex}`);
      });
      
      // Afficher les timestamps actuels
      console.log('‚è±Ô∏è [DEBUG] Timestamps actuels:', this.questionStartTimes);
    }
    
    // Forcer la r√©cup√©ration des timestamps
    this.fetchQuestionStartTimes().then(() => {
      if (showDiagnostic) {
        console.log('‚è±Ô∏è [DEBUG] Nouveaux timestamps:', this.questionStartTimes);
      }
      
      // Forcer la r√©cup√©ration directe des participants
      this.checkParticipantsDirectly().then(() => {
        console.log('üë• [DEBUG] Participants r√©cup√©r√©s directement:', this.participants.length);
        
        // Forcer la mise √† jour du classement
        this.updateLeaderboard();
        
        // Ex√©cuter le diagnostic avanc√© si demand√©
        if (showDiagnostic) {
          setTimeout(() => {
            console.log('üîç [DEBUG] Ex√©cution du diagnostic avanc√© du leaderboard...');
            
            // G√©n√©rer un rapport de diagnostic complet
            this.quizService.getAllAnswers$().subscribe(allAnswersDocs => {
              generateLeaderboardDiagnostic(
                this.leaderboard, 
                this.participants,
                this.goodAnswersTimesByUser,
                this.formatTime.bind(this)
              );
              
              // V√©rifier la synchronisation entre les questions et les r√©ponses
              checkAnswersQuestionsSynchronization(allAnswersDocs, this.quizService.getQuestions());
            });
          }, 1000);
        }
        
        this.cdr.detectChanges();
      });
    });
  }

  private readonly apiUrl = environment.apiUrl;

  constructor(
    public quizService: QuizService,
    private timerService: TimerService,
    private cdr: ChangeDetectorRef,
    public adminAuthService: AdminAuthService,
    public router: Router,
    private websocketTimerService: WebSocketTimerService,
    private http: HttpClient
  ) {
    // Initialiser les souscriptions imm√©diatement pour assurer la synchronisation
    this.initializeSubscriptions();
    
    // Configurer les m√©thodes de d√©bogage d'images avec d√©tection de changements
    setupImageDebug(this, this.cdr);
  }

  private initializeSubscriptions(force: boolean = false) {
    // √âviter la duplication des souscriptions sauf si forc√©
    if (this.subscriptions.length > 0 && !force) {
      console.log('‚ö†Ô∏è  Souscriptions d√©j√† initialis√©es, ignorer');
      return;
    }

    // Si forc√©, nettoyer d'abord les anciennes souscriptions
    if (force && this.subscriptions.length > 0) {
      console.log('üîÑ Nettoyage des anciennes souscriptions avant r√©initialisation');
      this.subscriptions.forEach(sub => sub.unsubscribe());
      this.subscriptions = [];
    }
    
    // Forcer une v√©rification synchrone de l'√©tat actuel
    this.quizService.forceCheckState().then(currentStep => {
      console.log('üëÅÔ∏è [DEBUG] √âtat forc√© v√©rifi√©:', currentStep);
      this.step = currentStep;
      this.cdr.detectChanges();
    });
    
    // Forcer la r√©cup√©ration des participants directement depuis le serveur
    fetch('http://localhost:3000/api/participants')
      .then(response => response.json())
      .then(data => {
        console.log('üë• [DEBUG] Participants r√©cup√©r√©s directement de l\'API:', data);
        if (Array.isArray(data) && data.length > 0) {
          this.participants = data;
          console.log('‚úÖ [DEBUG] Participants d√©finis manuellement:', this.participants);
          this.cdr.detectChanges();
        }
      })
      .catch(error => console.error('‚ùå [DEBUG] Erreur r√©cup√©ration participants:', error));

    console.log('üîÑ Initialisation des souscriptions...');

    // ‚úÖ S'abonner aux changements de questions
    const questionsSub = this.quizService.questions$.subscribe(questions => {
      if (questions.length > 0) {
        console.log(`[PRESENTATION-QUESTIONS] Nouvelle liste de questions re√ßue: ${questions.length} questions`);

        // Mettre √† jour la question courante si elle a chang√©
        const newCurrentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);
        if (newCurrentQuestion &&
            (!this.currentQuestion || this.currentQuestion.id !== newCurrentQuestion.id)) {

          console.log(`[PRESENTATION-QUESTIONS] Question ${this.currentIndex} mise √† jour:`, {
            ancien: this.currentQuestion?.text?.substring(0, 50) + '...',
            nouveau: newCurrentQuestion.text?.substring(0, 50) + '...'
          });

          this.currentQuestion = newCurrentQuestion;
        }
      }
    });
    this.subscriptions.push(questionsSub);

    // ‚úÖ S'abonner aux transitions d'√©tapes synchronis√©es via WebSocket
    const stepTransitionSub = this.websocketTimerService.getStepTransitions().subscribe(transitionData => {
      console.log('[PRESENTATION][STEP-WS] Transition re√ßue:', transitionData);
      this.showLoadingForTransition('question-start'); // Type par d√©faut pour les transitions
    });
    this.subscriptions.push(stepTransitionSub);

    const stepActivationSub = this.websocketTimerService.getStepActivations().subscribe(activationData => {
      console.log('[PRESENTATION][STEP-WS] Activation re√ßue:', activationData);

      // Gestion structure imbriqu√©e
      let stepValue = activationData.step;
      const rawData = activationData as any;
      if (!stepValue && rawData.data && rawData.data.step) {
        stepValue = rawData.data.step;
        console.log('[PRESENTATION][STEP-WS] √âtape extraite de structure imbriqu√©e:', stepValue);
      }

      console.log('[PRESENTATION][STEP-WS] √âtape finale:', stepValue);

      this.isLoading = false;
      this.step = stepValue as QuizStep;

      // Actions sp√©cifiques aux √©tapes apr√®s activation synchronis√©e
      this.handleStepActivationPresentation(stepValue as QuizStep);

      this.refresh();
      this.cdr.detectChanges();
    });
    this.subscriptions.push(stepActivationSub);

    // Synchro temps r√©el de l'√©tape du quiz (fallback pour compatibilit√©)
    let lastStep: string | null = null;
    const stepSub = this.quizService.getStep().subscribe(step => {
      if (!step || step === lastStep) return;

      console.log('[PRESENTATION][STEP-FALLBACK] Changement d\'√©tape :', lastStep, '->', step);
      lastStep = step;

      // Changement direct si WebSocket ne fonctionne pas
      this.step = step as QuizStep;
      this.handleStepActivationPresentation(step as QuizStep);
      this.refresh();
      this.cdr.detectChanges();
    });
    this.subscriptions.push(stepSub);

    // Synchro temps r√©el de l'index de la question
    const indexSub = this.quizService.getCurrentIndex().subscribe(async idx => {
      const previousIndex = this.currentIndex;
      this.currentIndex = idx;

      // Reset image states immediately when index changes to prevent flash
      if (previousIndex !== idx) {
        this.imageLoaded = false;
        this.resultImageLoaded = false;
        this.hideImages = false; // Allow images to show again for new question
        // Force immediate UI update to hide images instantly
        this.cdr.detectChanges();
        console.log('[DEBUG][INDEX] Image states reset for index change:', previousIndex, '->', idx);
      }

      await this.fetchQuestionStartTimes(); // Rafra√Æchit les timestamps √† chaque question
      this.refresh();
      // Synchro temps r√©el des votants pour la question courante
      const votersSub = this.quizService.getVoters$(idx).subscribe((voters: {id: any, name: any}[]) => {
        this.voters = voters;
      });
      this.subscriptions.push(votersSub);

      // Synchro temps r√©el du nombre de r√©ponses par option
      if (this.answersCountSub) this.answersCountSub.unsubscribe();
      console.log('[DEBUG][SUBSCRIPTION] Starting getAnswersCount$ subscription for question:', idx);
      this.answersCountSub = this.quizService.getAnswersCount$(idx).subscribe(counts => {
        console.log('[DEBUG][SUBSCRIPTION] getAnswersCount$ returned:', counts);
        this.answersCount = counts;
        this.refresh();
      });
      // Optimis√© : calcul du leaderboard sans logs excessifs
      this.updateLeaderboard();
    });
    this.subscriptions.push(indexSub);

    // Synchro temps r√©el des inscrits - optimis√© pour 60+ participants
    const participantsSub = this.quizService.getParticipants$().subscribe(participants => {
      const oldCount = this.participants.length;
      console.log('[PRESENTATION][DEBUG] getParticipants$ a retourn√©:', participants.length, 'participants');

      // Eviter les fluctuations si la liste est vide temporairement
      if (participants.length === 0 && oldCount > 0) {
        console.log('[PRESENTATION] Liste participants temporairement vide - conservation de la liste pr√©c√©dente');
        return; // Ne pas vider la liste si elle √©tait non-vide avant
      }

      this.participants = participants;
      const newCount = this.participants.length;

      if (oldCount !== newCount) {
        console.log(`[PRESENTATION] Participants: ${oldCount} ‚Üí ${newCount}`, 
                    'Noms:', participants.map(p => p.name).join(', '));
      } else if (participants.length > 0) {
        console.log('[PRESENTATION] M√™me nombre de participants:', newCount,
                    'Noms:', participants.map(p => p.name).join(', '));
      }
      
      // Forcer la mise √† jour de l'interface dans tous les cas
      this.cdr.detectChanges();
      
      // V√©rifier si les participants devraient √™tre visibles dans l'√©cran actuel
      if (this.step === 'lobby' || this.step === 'waiting') {
        console.log(`[PRESENTATION][DEBUG] Dans l'√©tape ${this.step} avec ${participants.length} participants`);
      }

      this.updateLeaderboard();
    });
    this.subscriptions.push(participantsSub);
    
    // Ajout: Forcer la r√©cup√©ration initiale des participants depuis le serveur
    this.quizService.fetchParticipantsFromServer().then(participants => {
      console.log('[PRESENTATION][INIT] Participants initiaux r√©cup√©r√©s:', participants.length);
      this.participants = participants;
      this.cdr.detectChanges();
    });

    // ‚úÖ S'abonner aux mises √† jour WebSocket du timer pour la synchronisation visuelle c√¥t√© pr√©sentation
    const timerWebSocketSub = this.websocketTimerService.getCountdown().subscribe(timerState => {
      console.log('[PRESENTATION][TIMER-WS] Timer update re√ßu:', timerState);

      // Mettre √† jour l'affichage du timer c√¥t√© pr√©sentation quand il est actif
      if (timerState.questionStartTime && timerState.questionStartTime > 0 && this.step === 'question') {
        this.timerValue = timerState.timeRemaining;
        this.timerMax = timerState.timerMax;
        this.timerActive = timerState.isActive;

        // Si le timer est d√©marr√© c√¥t√© serveur, marquer comme d√©marr√© manuellement
        if (!this.timerStartedManually) {
          this.timerStartedManually = true;
          console.log('[PRESENTATION][TIMER-WS] Timer d√©marr√© d√©tect√©, timerStartedManually = true');
        }

        // Mise √† jour visuelle imm√©diate
        this.cdr.detectChanges();

        console.log('[PRESENTATION][TIMER-WS] Timer visuel mis √† jour:', {
          timeRemaining: this.timerValue,
          isActive: this.timerActive,
          timerMax: this.timerMax
        });
      } else if (timerState.questionStartTime === 0 && this.step === 'question') {
        // Timer pas encore d√©marr√©, r√©initialiser l'affichage
        this.timerActive = false;
        this.timerValue = timerState.timerMax || 20;
        this.timerStartedManually = false;
        console.log('[PRESENTATION][TIMER-WS] Timer en attente, timerStartedManually = false');
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(timerWebSocketSub);
  }

  // Retourne le temps total des bonnes r√©ponses pour un user
  public getTotalGoodAnswersTime(userId: string): number {
    // Protection contre les valeurs non d√©finies
    if (!userId || !this.goodAnswersTimesByUser) return 0;
    
    // Obtenir le tableau des temps, ou tableau vide si non d√©fini
    const arr = this.goodAnswersTimesByUser[userId] || [];
    
    // Log pour le diagnostic des temps par utilisateur
    const validTimes = arr.filter(time => typeof time === 'number' && !isNaN(time));
    const total = validTimes.reduce((sum, time) => sum + time, 0);
    
    // Log d√©taill√© uniquement pour les utilisateurs avec des temps (pour √©viter trop de logs)
    if (validTimes.length > 0) {
      console.log(`[TIME-DIAG] ‚è±Ô∏è User ${userId}: ${validTimes.length} temps valides, total: ${this.formatTime(total)}`);
      console.log(`[TIME-DIAG] D√©tail:`, validTimes.map((time, idx) => `Q${idx}: ${time ? this.formatTime(time) : '-'}`).join(', '));
    }
    
    // Filtrer les valeurs valides et faire la somme
    return total;
  }

  // M√©thode optimis√©e pour mettre √† jour le leaderboard sans logs excessifs
  private updateLeaderboard(): void {
    // Si pas de participants, pas besoin de calculer le leaderboard
    if (this.participants.length === 0) {
      this.leaderboard = [];
      console.log('[LEADERBOARD] Aucun participant, leaderboard vide.');
      return;
    }
    
    console.log('[LEADERBOARD-DIAG] üîç D√©but du calcul du leaderboard avec', this.participants.length, 'participants');
    console.log('[LEADERBOARD-DIAG] üìã Liste des participants:', this.participants.map(p => p.name).join(', '));

    this.fetchQuestionStartTimes().then(() => {
      const subscription = this.quizService.getAllAnswers$().subscribe((allAnswersDocs: any[]) => {
        const nbQuestions = this.quizService.getQuestions().length;

        // Si pas de questions, pas de leaderboard
        if (nbQuestions === 0) {
          this.leaderboard = [];
          console.log('[LEADERBOARD] Aucune question, leaderboard vide.');
          return;
        }

        // Journal d√©taill√© des documents de r√©ponses
        console.log('[LEADERBOARD] üìä Mise √† jour du classement:', {
          participants: this.participants.length,
          nbQuestions,
          allAnswersDocs: allAnswersDocs.length
        });

        // Pour le debug, afficher les IDs des documents de r√©ponses
        console.log('[LEADERBOARD] üìù IDs des documents de r√©ponses:', allAnswersDocs.map(d => d.id));

        // Nous affichons tous les participants, qu'ils aient r√©pondu correctement ou non
        console.log('[LEADERBOARD] üëç Calcul du classement pour tous les participants...');
        
        console.log('[LEADERBOARD] üëç Au moins une r√©ponse valide trouv√©e, calcul du classement...');
        
        console.log('[LEADERBOARD-DIAG] üß© Document de r√©ponses disponibles:', allAnswersDocs.map(doc => `ID:${doc.id}, R√©ponses:${doc.answers?.length || 0}`).join(' | '));

        const leaderboard: LeaderboardEntry[] = this.participants.map(user => {
          let score = 0;
          let totalTime = 0;
          let goodTimes: number[] = [];
          // Flag pour suivre les bonnes r√©ponses √† la question actuelle
          let currentQuestionCorrect = false;

          console.log('[LEADERBOARD] üßÆ Calcul du score pour:', user.name);

          // Pour chaque question du quiz
          for (let i = 0; i < nbQuestions; i++) {
            // R√©cup√©rer la question actuelle pour conna√Ætre son ID et l'index correct
            const question = this.quizService.getCurrentQuestion(i);
            if (!question) {
              console.log(`[LEADERBOARD] ‚ö†Ô∏è Question ${i} introuvable, ignor√©e pour ${user.name}`);
              goodTimes[i] = undefined as any;
              continue;
            }
            
            // Journal pour tracer la question
            console.log(`[LEADERBOARD] üìù V√©rification Q${i} (ID:${question.id}) pour ${user.name}`);
            
            // STRAT√âGIE ROBUSTE: Recherche des r√©ponses avec multiple strat√©gies
            let docAns = null;
            let answerSource = '';
            
            // 1. D'abord chercher par index (cas le plus courant)
            docAns = allAnswersDocs.find((d: any) => String(d.id) === String(i));
            if (docAns) {
              answerSource = 'index';
              console.log(`[LEADERBOARD] ‚úÖ R√©ponses trouv√©es pour Q${i} via index direct`);
            }
            
            // 2. Si pas trouv√© et ID diff√©rent, chercher par ID de question
            if (!docAns && question && question.id !== undefined && question.id !== i) {
              const docAnsById = allAnswersDocs.find((d: any) => String(d.id) === String(question.id));
              if (docAnsById) {
                docAns = docAnsById;
                answerSource = 'id';
                console.log(`[LEADERBOARD] üîç R√©ponses trouv√©es via ID=${question.id} plut√¥t que index=${i}`);
              }
            }
            
            // 3. Chercher par questionId explicite (si pr√©sent dans les documents)
            if (!docAns) {
              const docAnsByQuestionId = allAnswersDocs.find((d: any) => 
                d.questionId !== undefined && String(d.questionId) === String(question.id)
              );
              if (docAnsByQuestionId) {
                docAns = docAnsByQuestionId;
                answerSource = 'questionId';
                console.log(`[LEADERBOARD] üîç R√©ponses trouv√©es via questionId=${question.id}`);
              }
            }
            
            // 4. Si toujours pas trouv√©, chercher par toute m√©thode approximative disponible
            if (!docAns) {
              console.log(`[LEADERBOARD] ‚ö†Ô∏è Aucune r√©ponse trouv√©e pour Q${i} (ID:${question.id}), recherche flexible...`);
              
              // Log d√©taill√© de tous les documents de r√©ponses disponibles pour faciliter le diagnostic
              console.log(`[LEADERBOARD-DIAG] üìã Documents de r√©ponses disponibles:`, 
                allAnswersDocs.map(d => `{id:${d.id}, questionId:${d.questionId||'undef'}, index:${d.index||'undef'}, r√©ponses:${d.answers?.length||0}}`).join('\n'));
              
              // Essai avec valeur enti√®re ou string (comparaisons faibles)
              docAns = allAnswersDocs.find((d: any) => d.id == i || d.id == question.id);
              if (docAns) {
                answerSource = 'flexible';
                console.log(`[LEADERBOARD] ‚úÖ R√©ponses trouv√©es par correspondance flexible pour Q${i}`);
              }
              
              // Recherche par index dans le document original
              if (!docAns) {
                const docAnsByIndex = allAnswersDocs.find((d: any) => d.index !== undefined && d.index == i);
                if (docAnsByIndex) {
                  docAns = docAnsByIndex;
                  answerSource = 'documentIndex';
                  console.log(`[LEADERBOARD] ‚úÖ R√©ponses trouv√©es via index explicite du document pour Q${i}`);
                }
                
                // DERNIER RECOURS: Parcourir tous les documents et chercher des r√©ponses
                if (!docAns) {
                  // Chercher n'importe quel document avec des r√©ponses
                  const docsWithAnswers = allAnswersDocs.filter(d => d.answers && d.answers.length > 0);
                  if (docsWithAnswers.length > 0) {
                    console.log(`[LEADERBOARD] üîç Recours ultime: ${docsWithAnswers.length} documents avec r√©ponses trouv√©s`);
                    // Prendre le premier document avec des r√©ponses
                    docAns = docsWithAnswers[0];
                    answerSource = 'lastResort';
                  }
                }
              }
            }
            
            // Si des r√©ponses sont trouv√©es, chercher celle de l'utilisateur
            if (docAns && docAns.answers) {
              const answers = docAns.answers.filter((a: any) => String(a.userId) === String(user.id));
              
              if (answers.length > 0) {
                // Prendre la derni√®re r√©ponse (la plus r√©cente)
                const answer = answers[answers.length - 1];

                // Normaliser les types pour la comparaison - avec logging pour diagnostic
                const userAnswerIndexRaw = answer.answerIndex;
                const correctAnswerIndexRaw = question.correctIndex;
                
                // Conversion explicite en nombre avec handling des cas sp√©ciaux
                const userAnswerIndex = typeof userAnswerIndexRaw === 'string' ? 
                                        parseInt(userAnswerIndexRaw, 10) : Number(userAnswerIndexRaw);
                const correctAnswerIndex = typeof correctAnswerIndexRaw === 'string' ? 
                                           parseInt(correctAnswerIndexRaw, 10) : Number(correctAnswerIndexRaw);
                
                // Log d√©taill√© des valeurs avant et apr√®s conversion pour diagnostic
                console.log(`[LEADERBOARD] üî¢ Q${i}: userAnswerIndex=${userAnswerIndexRaw}(${typeof userAnswerIndexRaw}) -> ${userAnswerIndex}(number), correctAnswerIndex=${correctAnswerIndexRaw}(${typeof correctAnswerIndexRaw}) -> ${correctAnswerIndex}(number)`);
                
                // D√©terminer si la r√©ponse est correcte avec comparaison souple (==) pour g√©rer les cas limites
                // mais uniquement apr√®s normalisation en nombre pour √©viter les faux positifs
                const isCorrect = !isNaN(userAnswerIndex) && !isNaN(correctAnswerIndex) && 
                                 userAnswerIndex == correctAnswerIndex; // Comparaison souple intentionnelle
                
                console.log(`[LEADERBOARD] üìä Q${i} (ID:${question.id}) - ${user.name}:`, {
                  r√©ponse: userAnswerIndex,
                  correcte: correctAnswerIndex,
                  correct: isCorrect,
                  source: answerSource
                });

                // Si la r√©ponse est correcte, ajouter au score
                if (isCorrect) {
                  score++;
                  
                  // Marquer comme correcte si c'est la question actuelle
                  if (i === this.currentIndex) {
                    currentQuestionCorrect = true;
                    console.log(`[LEADERBOARD] üéØ Bonne r√©ponse √† la question actuelle pour ${user.name}`);
                  }
                  
                  // CALCUL DU TEMPS DE R√âPONSE - M√âTHODE ROBUSTE
                  let qStart = null;
                  
                  // 1. Essayer avec l'ID de la question
                  if (question.id !== undefined) {
                    qStart = this.questionStartTimes[question.id] || this.questionStartTimes[String(question.id)];
                  }
                  
                  // 2. Fallback sur l'index si pas trouv√© par ID
                  if (!qStart) {
                    qStart = this.questionStartTimes[i] || this.questionStartTimes[String(i)];
                  }
                  
                  // 3. Si toujours rien, cr√©er un timestamp par d√©faut
                  if (!qStart && answer.timestamp) {
                    qStart = answer.timestamp - 10000; // Par d√©faut: 10 secondes
                    console.warn(`[LEADERBOARD] ‚è±Ô∏è Aucun timestamp trouv√© pour Q${i} (ID:${question.id}), valeur par d√©faut utilis√©e`);
                  }
                  
                  // Calculer le temps effectif pris pour r√©pondre
                  if (answer.timestamp && qStart && answer.timestamp >= qStart) {
                    const timeTaken = Math.min(answer.timestamp - qStart, 20000); // Max 20s
                    goodTimes[i] = timeTaken;
                    totalTime += timeTaken;
                    console.log(`[LEADERBOARD] ‚è±Ô∏è Temps pour ${user.name}, Q${i}: ${timeTaken}ms (${this.formatTime(timeTaken)})`);
                  } else if (answer.timestamp) {
                    // Si timestamp invalide, valeur par d√©faut
                    const defaultTime = 15000; // 15 secondes
                    goodTimes[i] = defaultTime;
                    totalTime += defaultTime;
                    console.warn(`[LEADERBOARD] ‚è±Ô∏è Timestamp invalide pour ${user.name}, Q${i}, d√©faut: ${defaultTime}ms`);
                  }
                } else {
                  // R√©ponse incorrecte
                  goodTimes[i] = undefined as any;
                }
              } else {
                // Pas de r√©ponse pour cet utilisateur
                goodTimes[i] = undefined as any;
              }
            } else {
              // Pas de document de r√©ponse trouv√©
              goodTimes[i] = undefined as any;
            }
          }

          console.log(`[LEADERBOARD] ‚ú® Score final pour ${user.name}: ${score}/${nbQuestions} (temps: ${this.formatTime(totalTime)})`);

          // Sauvegarder les temps pour utilisation ult√©rieure
          this.goodAnswersTimesByUser[user.id] = goodTimes;
          
          // Cr√©er l'entr√©e pour le tableau de classement avec toutes les donn√©es
          return { 
            id: user.id, 
            name: user.name, 
            avatarUrl: user.avatarUrl, 
            score, 
            totalTime,
            currentQuestionCorrect, // Nouveau: indique si bonne r√©ponse √† la question actuelle
          };
        });

        // Tri du classement: d'abord par score, puis par temps
        this.leaderboard = leaderboard.sort((a, b) => {
          // Tri principal par score (d√©croissant)
          if (b.score !== a.score) return b.score - a.score;
          
          // Tri secondaire par temps (croissant = meilleur)
          return a.totalTime - b.totalTime;
        });

        // Journal d√©taill√© du leaderboard r√©sultant
        console.log(`[LEADERBOARD] üèÜ Classement g√©n√©r√©: ${this.leaderboard.length} entr√©es`);
        if (this.leaderboard.length > 0) {
          console.log('[LEADERBOARD] ü•á Premier:', this.leaderboard[0].name, 
                      `(${this.leaderboard[0].score}pts, ${this.formatTime(this.leaderboard[0].totalTime)})`);
          
          // Log d√©taill√© du classement complet pour le diagnostic
          console.log('[LEADERBOARD-DIAG] üìä Classement complet:');
          this.leaderboard.forEach((entry, idx) => {
            console.log(`[LEADERBOARD-DIAG] ${idx + 1}. ${entry.name}: ${entry.score}pts, ${this.formatTime(entry.totalTime)} (ID: ${entry.id})`);
          });
        }
        
        // Forcer la mise √† jour de l'interface
        this.cdr.detectChanges();
      });

      this.subscriptions.push(subscription);
    });
  }

  // R√©cup√®re les questionStartTimes via l'API HTTP
  public async fetchQuestionStartTimes(): Promise<void> {
    try {
      // R√©cup√©ration des timestamps depuis le serveur
      try {
        const response = await this.http.get(`${this.apiUrl}/quiz/question-start-times`).toPromise();
        if (response && typeof response === 'object') {
          console.log('[TIMESTAMPS] R√©cup√©ration r√©ussie:', response);
          this.questionStartTimes = response as Record<string, number>;
        } else {
          console.warn('[TIMESTAMPS] Format de r√©ponse inattendu:', response);
          this.questionStartTimes = {};
        }
      } catch (apiError) {
        console.warn('[TIMESTAMPS] Erreur API, cr√©ation locale:', apiError);
        
        // Fallback: cr√©er un objet de timestamps bas√©s sur les questions actuelles
        const questions = this.quizService.getQuestions();
        const timestamps: Record<string, number> = {};
        
        questions.forEach((q, index) => {
          // On utilise l'ID de la question comme cl√©, pas l'index
          if (q && q.id !== undefined) {
            timestamps[q.id] = Date.now() - (index * 60000); // Simulation: question d√©marr√©e il y a (index * 1min)
            timestamps[String(index)] = timestamps[q.id]; // Double r√©f√©rence par index et par ID
            
            // Diagnostic pour les probl√®mes d'ID
            if (index !== q.id) {
              console.warn(`[TIMESTAMPS] Question trouv√©e √† l'index ${index}, mais son ID=${q.id} est diff√©rent (‚ö†Ô∏è potentiel probl√®me de score)`);
            }
          }
        });
        
        this.questionStartTimes = timestamps;
        console.log('[TIMESTAMPS] Timestamps cr√©√©s localement:', this.questionStartTimes);
      }
    } catch (e) {
      console.error('Erreur r√©cup√©ration questionStartTimes', e);
      this.questionStartTimes = {};
    }
  }

  /* Fonction Skip d√©sactiv√©e - le bouton a √©t√© retir√© de l'interface
  forceEndTimer() {
    // Appel backend pour forcer la fin du timer chez tous les joueurs
    try {
  this.http.post('/api/quiz/skip-timer', {}, { responseType: 'json' }).subscribe({
        next: (response) => {
          console.log('[SKIP-TIMER] R√©ponse backend (type):', typeof response, response);
          try {
            if (response && (response as any).success) {
              this.timerValue = 0;
              this.stopTimer();
              this.showResult();
            } else {
              alert('R√©ponse inattendue du backend : ' + JSON.stringify(response));
            }
          } catch (e) {
            alert('Erreur de parsing de la r√©ponse backend : ' + e);
          }
        },
        error: (err) => {
          console.error('[SKIP-TIMER] Erreur HTTP :', err);
          let msg = 'Erreur lors du skip timer : ';
          if (err.status) msg += `HTTP ${err.status} - `;
          if (err.error && typeof err.error === 'object') {
            msg += JSON.stringify(err.error);
          } else if (err.error) {
            msg += err.error;
          } else if (err.message) {
            msg += err.message;
          }
          if (err instanceof ProgressEvent && err.type === 'error') {
            msg += ' (Erreur r√©seau/fetch : la connexion a √©chou√© ou a √©t√© bloqu√©e par le navigateur)';
          }
          alert(msg);
        }
      });
    } catch (e) {
      alert('Erreur JS lors de l‚Äôappel skip-timer : ' + e);
      console.error('[SKIP-TIMER] Exception JS :', e);
    }
  }

  // ngOnInit fusionn√© ci-dessus

  refresh() {
    // this.participants = ... supprim√©, car synchro via API SQLite
    const previousQuestion = this.currentQuestion;
    this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

    // Reset image loaded state IMMEDIATELY when question changes to prevent flash
    if (previousQuestion?.id !== this.currentQuestion?.id) {
      this.imageLoaded = false;
      this.resultImageLoaded = false;
      this.hideImages = false; // Allow images to show for new question
      console.log('[DEBUG][REFRESH] Image states reset due to question change');
    }

    // Ne pas √©craser le leaderboard dynamique ici !

    console.log('[DEBUG][REFRESH] currentQuestion:', this.currentQuestion);
    console.log('[DEBUG][REFRESH] answersCount:', this.answersCount);
    console.log('[DEBUG][REFRESH] currentIndex:', this.currentIndex);

    if (this.currentQuestion && this.answersCount) {
      console.log('[DEBUG][REFRESH] correctIndex:', this.currentQuestion.correctIndex);
      this.totalGood = this.answersCount[this.currentQuestion.correctIndex] || 0;
      this.totalAnswers = this.answersCount.reduce((a, b) => a + b, 0);
      this.totalBad = this.totalAnswers - this.totalGood;

      console.log('[DEBUG][REFRESH] Calculated values:', {
        totalGood: this.totalGood,
        totalBad: this.totalBad,
        totalAnswers: this.totalAnswers
      });
    } else {
      this.totalGood = 0;
      this.totalAnswers = 0;
      this.totalBad = 0;
      console.log('[DEBUG][REFRESH] Reset to 0 - missing currentQuestion or answersCount');
    }
  }
      async launchGame() {
    // Passe √† l'√©tape "waiting" avant de lancer la premi√®re question
    console.log("[DEBUG] launchGame() appel√© - Passage √† l'√©tape 'waiting'");
    try {
      const success = await this.quizService.setStep('waiting');
      console.log("[DEBUG] √âtape 'waiting' d√©finie avec succ√®s =", success);
      
      // Force la v√©rification de l'√©tat apr√®s un court d√©lai pour s'assurer que la transition a eu lieu
      setTimeout(async () => {
        const currentStep = await this.quizService.forceCheckState();
        console.log("[DEBUG] V√©rification d'√©tat apr√®s transition: step =", currentStep);
        
        if (currentStep !== 'waiting') {
          console.error("[DEBUG] ERREUR: L'√©tat n'est pas pass√© √† 'waiting' comme pr√©vu");
          // Nouvelle tentative
          console.log("[DEBUG] Nouvelle tentative de passage √† l'√©tape 'waiting'");
          await this.quizService.setStep('waiting');
        }
      }, 1000);
    } catch (error) {
      console.error("[ERROR] Erreur lors du passage √† l'√©tape 'waiting':", error);
    }
  }
    console.log("[DEBUG] launchGame() appel√© - Passage √† l'√©tape 'waiting'");
    try {
      const success = await this.quizService.setStep('waiting');
      console.log("[DEBUG] √âtape 'waiting' d√©finie avec succ√®s =", success);
      
      // Force la v√©rification de l'√©tat apr√®s un court d√©lai pour s'assurer que la transition a eu lieu
      setTimeout(async () => {
        const currentStep = await this.quizService.forceCheckState();
        console.log("[DEBUG] V√©rification d'√©tat apr√®s transition: step =", currentStep);
        
        if (currentStep !== 'waiting') {
          console.error("[DEBUG] ERREUR: L'√©tat n'est pas pass√© √† 'waiting' comme pr√©vu");
          // Nouvelle tentative
          console.log("[DEBUG] Nouvelle tentative de passage √† l'√©tape 'waiting'");
          await this.quizService.setStep('waiting');
        }
      }, 1000);
    } catch (error) {
      console.error("[ERROR] Erreur lors du passage √† l'√©tape 'waiting':", error);
    }
  }
    console.log("[DEBUG] launchGame() appel√© - Passage √† l'√©tape \"waiting\"");
    try {
      const success = await this.quizService.setStep('waiting');
      console.log("[DEBUG] √âtape \"waiting\" d√©finie avec succ√®s =", success);
      
      // Force la v√©rification de l'√©tat apr√®s un court d√©lai pour s'assurer que la transition a eu lieu
      setTimeout(async () => {
        const currentStep = await this.quizService.forceCheckState();
        console.log("[DEBUG] V√©rification d'√©tat apr√®s transition: step =", currentStep);
        
        if (currentStep !== 'waiting') {
          console.error("[DEBUG] ERREUR: L'√©tat n'est pas pass√© √† \"waiting\" comme pr√©vu");
          // Nouvelle tentative
          console.log("[DEBUG] Nouvelle tentative de passage √† l'√©tape \"waiting\"");
          await this.quizService.setStep('waiting');
        }
      }, 1000);
    } catch (error) {
      console.error("[ERROR] Erreur lors du passage √† l'√©tape \"waiting\":", error);
    }
  }

  // M√©thode √† appeler pour vraiment d√©marrer la premi√®re question apr√®s l'attente
  async startFirstQuestion() {
    // D√©marre la premi√®re question via l'API HTTP
    try {
      // Utilise nextQuestion(-1) pour forcer le passage √† l'index 0 avec initialisation du timer
      await this.quizService.nextQuestion(-1);
      console.log('[INFO] First question started via HTTP API');
    } catch (error) {
      console.error('Erreur lors du d√©marrage de la premi√®re question:', error);
    }
  }

  startTimer() {
    this.stopTimer();
    this.syncTimerWithServer();
  }

  private async checkAndSyncTimer() {
    try {
      const gameState = await this.quizService.getGameState();

      if (gameState?.questionStartTime) {
        // Le serveur a d√©j√† un questionStartTime, synchroniser
        console.log('üïê Question d√©j√† d√©marr√©e c√¥t√© serveur, synchronisation...');
        this.syncTimerWithServer();
      } else {
        // Pas de questionStartTime c√¥t√© serveur, ne pas d√©marrer le timer
        console.log('‚è∏Ô∏è Pas de timer c√¥t√© serveur, service centralis√© g√®re l\'√©tat');
        // Le service centralis√© g√®re l'√©tat par d√©faut
      }
    } catch (error) {
      console.warn('Erreur v√©rification timer serveur, service centralis√© prend le relais:', error);
      // Le service centralis√© g√®re l'√©tat par d√©faut en cas d'erreur
    }
  }

  private async syncTimerWithServer() {
    try {
      console.log('üïê [PRESENTATION] Synchronisation timer centralis√©e (auto-d√©marrage)');

      // S'abonner aux mises √† jour du timer centralis√© (d√©marrage automatique)
      if (this.timerSub) this.timerSub.unsubscribe();

      this.timerSub = this.timerService.getCountdown().subscribe(timerState => {
        const countdown = timerState.countdownToStart || 0;

        if (countdown > 0) {
          // Mode countdown avant d√©marrage
          this.timerValue = countdown;
          this.timerMax = countdown;
          console.log(`‚è≥ [PRESENTATION] Countdown: Question d√©marre dans ${countdown}s`);
        } else {
          // Mode timer normal
          this.timerValue = timerState.timeRemaining;
          this.timerMax = timerState.timerMax;
          console.log(`üïê [PRESENTATION] Timer: ${timerState.timeRemaining}s/${timerState.timerMax}s, active: ${timerState.isActive}`);

          if (timerState.timeRemaining <= 0 && timerState.isActive === false) {
            this.showResult();
          }
        }
      });

      // Le service centralis√© g√®re la synchronisation initiale automatiquement
      console.log('üïê [PRESENTATION] Service centralis√© actif, synchronisation automatique');

    } catch (error) {
      console.warn('Erreur synchronisation timer, fallback au service centralis√©:', error);
      // Fallback: utiliser le service centralis√© avec d√©marrage simple
      this.timerService.start(20);
    }
  }

  // DEPRECATED: Ancienne m√©thode remplac√©e par le service timer centralis√©
  private startTimerNormal_DEPRECATED(duration: number = 20) {
    console.warn('‚ö†Ô∏è startTimerNormal_DEPRECATED appel√©e - utiliser le service centralis√© √† la place');
    // Ne plus utiliser cette m√©thode, utiliser timerService.startServerSync() √† la place
    this.timerService.start(duration);
  }

  stopTimer() {
    if (this.timerSub) this.timerSub.unsubscribe();
    this.timerService.stopServerSync(); // Arr√™ter la synchronisation centralis√©e
  }

  showResult() {
    // DEBUG : log √©tat avant passage √† l'√©tape r√©sultat
    // Reset image states IMMEDIATELY to prevent any flash
    this.imageLoaded = false;
    this.resultImageLoaded = false;
    // Force immediate UI update to hide images instantly
    this.cdr.detectChanges();

    // On force la mise √† jour des donn√©es avant d'afficher le r√©sultat
    const previousQuestion = this.currentQuestion;
    this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

    // answersCount est toujours √† jour via l'abonnement (voir ngOnInit)
    if (this.currentQuestion && this.answersCount && Array.isArray(this.answersCount)) {
      this.totalGood = this.answersCount[this.currentQuestion.correctIndex] || 0;
      this.totalAnswers = this.answersCount.reduce((a, b) => a + b, 0);
      this.totalBad = this.totalAnswers - this.totalGood;
    } else {
      this.totalGood = 0;
      this.totalAnswers = 0;
      this.totalBad = 0;
    }
    // Passage √† l'√©tape r√©sultat avec d√©lai pour laisser le flux RxJS se mettre √† jour
    setTimeout(() => {
      this.quizService.setStep('result');
      this.step = 'result'; // Synchronisation imm√©diate pour le template
      this.refresh(); // Correction : forcer la mise √† jour des donn√©es juste apr√®s le changement d'√©tape
      this.cdr.markForCheck();
      // Log apr√®s le changement d'√©tape
      console.log('[DEBUG][RESULT] step:', this.step, 'currentQuestion:', this.currentQuestion, 'answersCount:', this.answersCount);
    }, 120);
  }

  async nextQuestion() {
    // Incr√©mente l'index et passe √† la question suivante via l'API
    try {
      console.log('[PRESENTATION] Next question via HTTP API, current index:', this.currentIndex);

      // Hide images immediately - most aggressive approach
      this.hideImages = true;
      this.imageLoaded = false;
      this.resultImageLoaded = false;

      // Reset timer immediately to sync with image change
      this.timerValue = 0;
      this.stopTimer();

      // Force immediate UI update to hide images instantly and show empty timer
      this.cdr.detectChanges();

      // Petit d√©lai pour laisser l'interface se mettre √† jour
      await new Promise(resolve => setTimeout(resolve, 50));

      // Reset timer to full immediately for visual sync
      this.timerValue = 20;
      this.timerMax = 20;
      this.cdr.detectChanges();

      // CORRECTION: Un seul appel qui g√®re tout (index + step + timer)
      await this.quizService.nextQuestion(this.currentIndex);
      console.log('[PRESENTATION] Question suivante appel√©e, nouvel index:', this.currentIndex + 1);
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors du passage √† la question suivante:', error);
    }
  }

  endGame() {
    this.quizService.setStep('end');
  }

  
  // R√©initialisation compl√®te du quiz (√©tape, participants, index, r√©ponses)
  async resetQuiz() {
    try {
      await this.quizService.resetParticipants();
      await this.quizService.resetAllAnswers();
      await this.quizService.setStep('lobby');
    } catch (error) {
      console.error('[RESET] ‚ùå Erreur lors de la r√©initialisation:', error);
      const errorMsg = error instanceof Error ? error.message : 'Erreur inconnue';
      alert(`Erreur lors de la r√©initialisation du quiz: ${errorMsg}`);
    }
    this.timerValue = 20;
    this.voters = [];

    // Arr√™ter les subscriptions existantes pour √©viter les logs r√©p√©t√©s
    this.subscriptions.forEach(sub => sub.unsubscribe());
    this.subscriptions = [];

    this.refresh();
  }

  // M√©thodes de gestion des images pour √©viter le flash
  onImageLoaded() {
    this.imageLoaded = true;
  }

  onImageError() {
    this.imageLoaded = false;
    console.warn('Erreur de chargement de l\'image:', this.currentQuestion?.imageUrl);
  }

  onResultImageLoaded() {
    this.resultImageLoaded = true;
  }

  onResultImageError() {
    this.resultImageLoaded = false;
    console.warn('Erreur de chargement de l\'image r√©sultat:', this.currentQuestion?.imageUrlResult);
  }

  // TrackBy function pour forcer la recr√©ation des √©l√©ments d'image
  trackByQuestionId(index: number, question: any): any {
    return question?.id || index;
  }

  // ===== M√âTHODES POUR LA PHOTO DE GROUPE =====

  async startCamera(): Promise<void> {
    try {
      // Calculer la r√©solution optimale bas√©e sur l'√©cran
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const aspectRatio = screenWidth / screenHeight;

      // Demander une r√©solution adapt√©e √† l'√©cran
      let videoConstraints: MediaTrackConstraints = {
        facingMode: 'user' // Cam√©ra frontale par d√©faut
      };

      // Adapter la r√©solution demand√©e √† l'√©cran
      if (aspectRatio > 1.5) {
        // √âcran large (16:9 ou plus)
        videoConstraints.width = { ideal: Math.min(1920, screenWidth * 0.9) };
        videoConstraints.height = { ideal: Math.min(1080, screenHeight * 0.9) };
      } else {
        // √âcran plus carr√©
        videoConstraints.width = { ideal: Math.min(1280, screenWidth * 0.9) };
        videoConstraints.height = { ideal: Math.min(720, screenHeight * 0.9) };
      }

      console.log('üìπ Demande de r√©solution cam√©ra:', videoConstraints);

      this.cameraStream = await navigator.mediaDevices.getUserMedia({
        video: videoConstraints,
        audio: false
      });

      this.cameraActive = true;
      this.cameraReady = false;
      this.showCameraModal = true;

      // Attendre que le DOM soit mis √† jour
      setTimeout(() => {
        const videoElement = document.getElementById('cameraVideo') as HTMLVideoElement;
        if (videoElement && this.cameraStream) {
          console.log('üìπ Configuration de l\'√©l√©ment vid√©o...');
          console.log('VideoElement trouv√©:', !!videoElement);
          console.log('CameraStream disponible:', !!this.cameraStream);

          // Forcer l'affichage de la vid√©o
          videoElement.style.display = 'block';
          videoElement.style.opacity = '1';
          videoElement.style.visibility = 'visible';
          videoElement.style.background = 'blue'; // Pour voir si l'√©l√©ment est visible

          videoElement.srcObject = this.cameraStream;

          // Attendre que les m√©tadonn√©es de la vid√©o soient charg√©es
          videoElement.onloadedmetadata = () => {
            console.log(`üìπ M√©tadonn√©es charg√©es: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
            console.log('üìπ ReadyState:', videoElement.readyState);
            console.log('üìπ Style computed:', window.getComputedStyle(videoElement).display);

            // Ajuster le container pour maintenir le ratio
            const container = videoElement.closest('.camera-container') as HTMLElement;
            if (container) {
              const ratio = videoElement.videoHeight / videoElement.videoWidth;
              container.style.aspectRatio = `${videoElement.videoWidth} / ${videoElement.videoHeight}`;
              console.log('üìπ Container aspect ratio d√©fini:', container.style.aspectRatio);
            }
          };

          // S'assurer que la vid√©o est bien en cours de lecture
          videoElement.oncanplay = () => {
            console.log('üìπ Vid√©o pr√™te pour la capture (canplay)');
            console.log('üìπ Video playing:', !videoElement.paused && !videoElement.ended && videoElement.readyState > 2);
            this.cameraReady = true;
          };

          videoElement.onloadeddata = () => {
            console.log('üìπ Donn√©es vid√©o charg√©es (loadeddata)');
            // Test si le stream est bien connect√©
            if (videoElement.srcObject === this.cameraStream) {
              console.log('‚úÖ Stream correctement assign√© √† la vid√©o');
            } else {
              console.error('‚ùå Stream non assign√© correctement');
              // R√©essayer d'assigner le stream
              videoElement.srcObject = this.cameraStream;
            }
          };

          videoElement.onplaying = () => {
            console.log('üìπ Vid√©o en cours de lecture (playing)');
          };

          videoElement.play().then(() => {
            console.log('üìπ Lecture vid√©o d√©marr√©e avec succ√®s');
            // Double v√©rification apr√®s 1 seconde
            setTimeout(() => {
              if (videoElement.readyState >= 2 && videoElement.videoWidth > 0) {
                this.cameraReady = true;
                console.log('üìπ Cam√©ra confirm√©e pr√™te');
                console.log('üìπ √âtat final - Paused:', videoElement.paused, 'Ended:', videoElement.ended, 'ReadyState:', videoElement.readyState);
              }
            }, 1000);
          }).catch(err => {
            console.error('‚ùå Erreur de lecture vid√©o:', err);
          });
        } else {
          console.error('‚ùå √âl√©ment vid√©o ou stream introuvable');
          console.log('VideoElement:', !!videoElement);
          console.log('CameraStream:', !!this.cameraStream);
        }
      }, 100);

      console.log('‚úÖ Cam√©ra d√©marr√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur d\'acc√®s √† la cam√©ra:', error);
      alert('Impossible d\'acc√©der √† la cam√©ra. V√©rifiez les permissions du navigateur.');
    }
  }

  async takeGroupPhoto(): Promise<void> {
    try {
      const videoElement = document.getElementById('cameraVideo') as HTMLVideoElement;

      if (!videoElement || !this.cameraStream) {
        console.error('√âl√©ments cam√©ra introuvables');
        return;
      }

      // V√©rifier que la vid√©o est bien en cours de lecture
      if (videoElement.readyState < 2) {
        console.error('Vid√©o pas encore pr√™te, readyState:', videoElement.readyState);
        alert('La cam√©ra n\'est pas encore pr√™te. Veuillez attendre quelques secondes et r√©essayer.');
        return;
      }

      // V√©rifier les dimensions de la vid√©o
      const videoWidth = videoElement.videoWidth;
      const videoHeight = videoElement.videoHeight;

      console.log(`üìπ Dimensions vid√©o: ${videoWidth}x${videoHeight}`);

      if (videoWidth === 0 || videoHeight === 0) {
        console.error('Dimensions vid√©o invalides');
        alert('Erreur: dimensions de la vid√©o invalides. Veuillez relancer la cam√©ra.');
        return;
      }

      // Cr√©er le canvas avec les bonnes dimensions
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        console.error('Impossible de cr√©er le contexte 2D');
        return;
      }

      // D√©finir les dimensions du canvas
      canvas.width = videoWidth;
      canvas.height = videoHeight;

      console.log(`üé® Canvas cr√©√©: ${canvas.width}x${canvas.height}`);

      // Capturer l'image de la vid√©o
      ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

      // V√©rifier que quelque chose a √©t√© captur√© (pixel test)
      const imageData = ctx.getImageData(0, 0, Math.min(10, canvas.width), Math.min(10, canvas.height));
      const hasContent = Array.from(imageData.data).some(value => value !== 0);

      if (!hasContent) {
        console.error('‚ö†Ô∏è Canvas semble vide, tentative avec d√©lai...');
        // Attendre un peu et r√©essayer
        await new Promise(resolve => setTimeout(resolve, 500));
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      }

      // Ajouter l'overlay "Promotion 2025"
      this.addPromotionOverlay(ctx, canvas.width, canvas.height);

      // T√©l√©charger l'image
      const link = document.createElement('a');
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0];
      link.download = `quiz-promotion-2025-${timestamp}.jpg`;

      // Utiliser une qualit√© plus √©lev√©e pour une meilleure image
      link.href = canvas.toDataURL('image/jpeg', 0.95);

      // D√©boguer: afficher la taille du dataURL
      console.log(`üì∏ Taille de l'image g√©n√©r√©e: ${link.href.length} caract√®res`);

      link.click();

      this.photoTaken = true;
      console.log('‚úÖ Photo de groupe prise avec succ√®s !');

      // Fermer la cam√©ra apr√®s 2 secondes
      setTimeout(() => {
        this.stopCamera();
      }, 2000);

    } catch (error) {
      console.error('‚ùå Erreur lors de la prise de photo:', error);
      alert('Erreur lors de la capture de la photo. Veuillez r√©essayer.');
    }
  }

  private addPromotionOverlay(ctx: CanvasRenderingContext2D, width: number, height: number): void {
    // Fond semi-transparent pour le texte
    ctx.fillStyle = 'rgba(35, 37, 38, 0.8)';
    ctx.fillRect(0, height - 100, width, 100);

    // Texte principal "Quiz Promotion 2025"
    ctx.fillStyle = '#f6d365';
    ctx.font = 'bold 32px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('üèÜ Quiz Promotion 2025', width / 2, height - 60);

    // Date
    const now = new Date();
    ctx.font = '18px Arial, sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(now.toLocaleDateString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }), width / 2, height - 25);

    // D√©coration coins
    ctx.fillStyle = '#DAE72A';
    ctx.font = '24px Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('üåü', 20, height - 40);
    ctx.textAlign = 'right';
    ctx.fillText('üåü', width - 20, height - 40);
  }

  stopCamera(): void {
    if (this.cameraStream) {
      // Arr√™ter tous les tracks de la cam√©ra
      this.cameraStream.getTracks().forEach(track => {
        track.stop();
      });
      this.cameraStream = null;
    }

    this.cameraActive = false;
    this.cameraReady = false;
    this.showCameraModal = false;
    this.photoTaken = false;
    console.log('‚úÖ Cam√©ra ferm√©e');
  }

  getCurrentDate(): string {
    return new Date().toLocaleDateString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }

  // ===== FIN M√âTHODES PHOTO DE GROUPE =====

  // M√©thode de capture graphique du leaderboard final
  async captureLeaderboard(): Promise<void> {
    try {
      // S√©lectionner un √©l√©ment plus large incluant le titre
      const element = document.querySelector('.container-question');
      if (!element) {
        console.error('√âl√©ment container-question introuvable pour la capture');
        return;
      }

      // Configuration html2canvas pour un rendu optimal
      const canvas = await html2canvas(element as HTMLElement, {
        backgroundColor: '#F1F1F1',
        scale: 2, // Haute r√©solution
        useCORS: true,
        allowTaint: false,
        width: (element as HTMLElement).offsetWidth,
        height: (element as HTMLElement).offsetHeight,
        scrollX: 0,
        scrollY: 0,
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        ignoreElements: (element) => {
          // Ignorer les boutons dans la capture
          return element.classList?.contains('step-final-buttons') || false;
        }
      });

      // Cr√©er un contexte pour ajouter des informations suppl√©mentaires
      const finalCanvas = document.createElement('canvas');
      const ctx = finalCanvas.getContext('2d');

      if (!ctx) return;

      // Dimensions du canvas final avec espace pour les m√©tadonn√©es
      const padding = 40;
      const headerHeight = 60;
      const footerHeight = 40;
      finalCanvas.width = canvas.width + (padding * 2);
      finalCanvas.height = canvas.height + headerHeight + footerHeight + (padding * 2);

      // Fond du canvas final
      ctx.fillStyle = '#F1F1F1';
      ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

      // Header avec titre
      ctx.fillStyle = '#232526';
      ctx.font = 'bold 28px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('üèÜ Quiz Application - Final Results', finalCanvas.width / 2, 35);

      // Ligne de s√©paration
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, headerHeight - 10);
      ctx.lineTo(finalCanvas.width - padding, headerHeight - 10);
      ctx.stroke();

      // Dessiner le leaderboard captur√©
      ctx.drawImage(canvas, padding, headerHeight + padding);

      // Footer avec date et heure
      const now = new Date();
      ctx.font = '14px Arial, sans-serif';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'center';
      ctx.fillText(`Generated on ${now.toLocaleString('fr-FR')}`, finalCanvas.width / 2, finalCanvas.height - 15);

      // T√©l√©charger l'image
      const link = document.createElement('a');
      const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0];
      link.download = `quiz-final-results-${timestamp}.png`;
      link.href = finalCanvas.toDataURL('image/png', 0.95);
      link.click();

      console.log('‚úÖ Capture du leaderboard r√©ussie !');
    } catch (error) {
      console.error('‚ùå Erreur lors de la capture:', error);
    }
  }

  // M√©thodes de gestion admin
  extendSession(): void {
    this.adminAuthService.extendSession();
  }

  logout(): void {
    if (confirm('√ätes-vous s√ªr de vouloir vous d√©connecter ?')) {
      this.adminAuthService.logout();
      this.router.navigate(['/admin-login']);
    }
  }

  getRemainingTime(): string {
    return this.adminAuthService.getFormattedRemainingTime();
  }

  // M√©thodes de restauration
  async onRestoreGame(): Promise<void> {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      await new Promise(resolve => setTimeout(resolve, this.minModalDisplayTime - elapsedTime));
    }

    try {
      console.log('üîÑ Tentative de restauration de la partie...');

      const restored = await this.quizService.restoreGameState();
      if (restored) {
        this.showRestoreDialog = false;

        // Synchroniser l'√©tat local avec l'√©tat restaur√©
        this.participants = this.quizService.participants;

        // R√©cup√©rer l'√©tape actuelle du serveur
        try {
          const gameState = await this.quizService.getGameState();
          this.step = gameState?.step || 'lobby';

          // Si on est dans une question, synchroniser le timer
          if (this.step === 'question') {
            console.log('üïê Restauration pendant une question, synchronisation du timer');
            await this.syncTimerWithServer();
          }

        } catch (error) {
          console.warn('Erreur lors de la r√©cup√©ration de l\'√©tape, utilisation de lobby par d√©faut');
          this.step = 'lobby';
        }

        console.log('‚úÖ Partie restaur√©e avec succ√®s !');

      } else {
        console.error('‚ùå Impossible de restaurer la partie');
        this.onStartNewGame();
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la restauration:', error);
      this.onStartNewGame();
    }
  }

  onStartNewGame(): void {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      setTimeout(() => {
        this.actuallyStartNewGame();
      }, this.minModalDisplayTime - elapsedTime);
    } else {
      this.actuallyStartNewGame();
    }
  }

  private actuallyStartNewGame(): void {
    console.log('üÜï D√©marrage d\'une nouvelle partie');
    this.showRestoreDialog = false;

    // Effacer la sauvegarde pr√©c√©dente
    this.quizService.clearSavedGameState();

    // Initialiser une nouvelle partie
    this.initializeNewGame();
  }

  /**
   * Synchronise l'√©tat local avec l'√©tat du serveur
   */
  private async synchronizeWithServer(serverState: any): Promise<void> {
    try {
      console.log('üîÑ Synchronisation avec l\'√©tat du serveur:', serverState);

      // Initialiser les composants de base
      this.quizService.initQuestions();

      // Synchroniser l'√©tape
      this.step = serverState.step || 'lobby';

      // Initialiser les souscriptions avec force pour s'assurer de la synchronisation
      this.initializeSubscriptions(true);

      // R√©cup√©rer la liste des participants depuis le serveur
      try {
        const participants = await this.quizService.fetchParticipantsFromServer();
        this.participants = participants || [];
        console.log('üë• Participants synchronis√©s:', this.participants.length);

        // Forcer la d√©tection des changements pour que l'UI se mette √† jour
        this.cdr.detectChanges();
        console.log('üîÑ D√©tection des changements forc√©e pour les participants');
      } catch (error) {
        console.warn('‚ö†Ô∏è Impossible de r√©cup√©rer les participants:', error);
        this.participants = [];
      }

      // Si on est dans une question, synchroniser l'index et le timer
      if (serverState.step === 'question') {
        this.currentIndex = serverState.currentQuestionIndex || 0;
        this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

        // Synchroniser le timer si n√©cessaire
        if (serverState.questionStartTime && serverState.questionStartTime > 0) {
          // Timer d√©j√† d√©marr√© sur le serveur, marquer comme d√©marr√© manuellement
          this.timerStartedManually = true;
          console.log('[SYNC] Timer d√©j√† d√©marr√© c√¥t√© serveur, timerStartedManually = true');
          this.checkAndSyncTimer();
        } else {
          // Timer pas encore d√©marr√©, rester en attente
          this.timerStartedManually = false;
          console.log('[SYNC] Timer pas encore d√©marr√© c√¥t√© serveur, timerStartedManually = false');
        }
      }

      // Si on est dans les r√©sultats, synchroniser l'index de la question
      if (serverState.step === 'result') {
        this.currentIndex = serverState.currentQuestionIndex || 0;
        this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);
      }

      // Forcer la d√©tection des changements
      this.cdr.detectChanges();

      console.log('‚úÖ Synchronisation termin√©e:', {
        step: this.step,
        currentIndex: this.currentIndex,
        participants: this.participants.length
      });

    } catch (error) {
      console.error('‚ùå Erreur lors de la synchronisation:', error);
      throw error;
    }
  }
  
  // M√©thodes de restauration
  async onRestoreGame(): Promise<void> {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      await new Promise(resolve => setTimeout(resolve, this.minModalDisplayTime - elapsedTime));
    }

    try {
      console.log('üîÑ Tentative de restauration de la partie...');

      const restored = await this.quizService.restoreGameState();
      if (restored) {
        this.showRestoreDialog = false;

        // Synchroniser l'√©tat local avec l'√©tat restaur√©
        this.participants = this.quizService.participants;

        // R√©cup√©rer l'√©tape actuelle du serveur
        try {
          const gameState = await this.quizService.getGameState();
          this.step = gameState?.step || 'lobby';

          // Si on est dans une question, synchroniser le timer
          if (this.step === 'question') {
            console.log('üïê Restauration pendant une question, synchronisation du timer');
            await this.syncTimerWithServer();
          }

        } catch (error) {
          console.warn('Erreur lors de la r√©cup√©ration de l\'√©tape, utilisation de lobby par d√©faut');
          this.step = 'lobby';
        }

        console.log('‚úÖ Partie restaur√©e avec succ√®s !');

      } else {
        console.error('‚ùå Impossible de restaurer la partie');
        this.onStartNewGame();
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la restauration:', error);
      this.onStartNewGame();
    }
  }

  onStartNewGame(): void {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      setTimeout(() => {
        this.actuallyStartNewGame();
      }, this.minModalDisplayTime - elapsedTime);
    } else {
      this.actuallyStartNewGame();
    }
  }

  private actuallyStartNewGame(): void {
    console.log('üÜï D√©marrage d\'une nouvelle partie');
    this.showRestoreDialog = false;

    // Effacer la sauvegarde pr√©c√©dente
    this.quizService.clearSavedGameState();

    // Initialiser une nouvelle partie
    this.initializeNewGame();
  }

  // Syst√®me de loading pour synchroniser avec les joueurs
  private showLoadingForTransition(type: string) {
    this.isLoading = true;
    this.loadingType = type;
    this.loadingMessage = this.getLoadingMessage(type);
    console.log('[PRESENTATION][LOADING] Transition:', type, 'Message:', this.loadingMessage);
  }

  private getLoadingMessage(type: string): string {
    switch (type) {
      case 'question-start': return 'Synchronisation...';
      case 'question-result': return 'R√©sultats...';
      case 'next-question': return 'Pr√©paration...';
      case 'quiz-end': return 'Termin√© !';
      default: return 'Synchronisation...';
    }
  }

  // Gestion des actions sp√©cifiques aux √©tapes pour la pr√©sentation
  private handleStepActivationPresentation(step: QuizStep) {
    console.log('[PRESENTATION][STEP-ACTIVATION] Traitement de l\'√©tape:', step);

    if (step === 'question') {
      // R√©initialiser le flag de d√©marrage manuel pour chaque nouvelle question
      this.timerStartedManually = false;
      // Ne plus d√©marrer automatiquement le timer - attendre le d√©marrage manuel
      console.log('[MANUAL-TIMER] Question affich√©e, en attente de d√©marrage manuel du timer');
    } else {
      this.stopTimer();
      this.timerStartedManually = false;
    }

    // R√©initialisation des r√©ponses lors du retour √† l'√©tape lobby
    if (step === 'lobby') {
      this.quizService.resetAllAnswers();
    }
  }

  // D√©marrage manuel du timer (synchronis√© avec tous les clients via WebSocket)
  async startTimerManually(duration: number = 20) {
    console.log('[MANUAL-TIMER] D√©marrage manuel du timer pour', duration, 'secondes');

    try {
      const response = await fetch(`${this.apiUrl}/start-timer`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          duration: duration,
          currentQuestionIndex: this.currentIndex
        })
      });

      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }

      const result = await response.json();
      console.log('[MANUAL-TIMER] Timer d√©marr√© avec succ√®s:', result);

      this.timerStartedManually = true;

    } catch (error) {
      console.error('[MANUAL-TIMER] Erreur lors du d√©marrage du timer:', error);
      // Fallback: d√©marrer localement si le serveur ne r√©pond pas
      this.timerStartedManually = true;
    }
  }

  refresh() {
    // this.participants = ... supprim√©, car synchro via API SQLite
    const previousQuestion = this.currentQuestion;
    this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

    // Reset image loaded state IMMEDIATELY when question changes to prevent flash
    if (previousQuestion?.id !== this.currentQuestion?.id) {
      this.imageLoaded = false;
      this.resultImageLoaded = false;
      this.hideImages = false; // Allow images to show for new question
      console.log('[DEBUG][REFRESH] Image states reset due to question change');
    }

    // Ne pas √©craser le leaderboard dynamique ici !

    console.log('[DEBUG][REFRESH] currentQuestion:', this.currentQuestion);
    console.log('[DEBUG][REFRESH] answersCount:', this.answersCount);
    console.log('[DEBUG][REFRESH] currentIndex:', this.currentIndex);

    if (this.currentQuestion && this.answersCount) {
      console.log('[DEBUG][REFRESH] correctIndex:', this.currentQuestion.correctIndex);
      this.totalGood = this.answersCount[this.currentQuestion.correctIndex] || 0;
      this.totalAnswers = this.answersCount.reduce((a, b) => a + b, 0);
      this.totalBad = this.totalAnswers - this.totalGood;

      console.log('[DEBUG][REFRESH] Calculated values:', {
        totalGood: this.totalGood,
        totalBad: this.totalBad,
        totalAnswers: this.totalAnswers
      });
    } else {
      this.totalGood = 0;
      this.totalAnswers = 0;
      this.totalBad = 0;
      console.log('[DEBUG][REFRESH] Reset to 0 - missing currentQuestion or answersCount');
    }
  }
  async launchGame() {
    // Passe √† l'√©tape "waiting" avant de lancer la premi√®re question
    console.log("[DEBUG] launchGame() appel√© - Passage √† l'√©tape \"waiting\"");
    try {
      const success = await this.quizService.setStep('waiting');
      console.log("[DEBUG] √âtape \"waiting\" d√©finie avec succ√®s =", success);
      
      // Force la v√©rification de l'√©tat apr√®s un court d√©lai pour s'assurer que la transition a eu lieu
      setTimeout(async () => {
        const currentStep = await this.quizService.forceCheckState();
        console.log("[DEBUG] V√©rification d'√©tat apr√®s transition: step =", currentStep);
        
        if (currentStep !== 'waiting') {
          console.error("[DEBUG] ERREUR: L'√©tat n'est pas pass√© √† \"waiting\" comme pr√©vu");
          // Nouvelle tentative
          console.log("[DEBUG] Nouvelle tentative de passage √† l'√©tape \"waiting\"");
          await this.quizService.setStep('waiting');
        }
      }, 1000);
    } catch (error) {
      console.error("[ERROR] Erreur lors du passage √† l'√©tape \"waiting\":", error);
    }
  }

  // M√©thode √† appeler pour vraiment d√©marrer la premi√®re question apr√®s l'attente
  async startFirstQuestion() {
    // D√©marre la premi√®re question via l'API HTTP
    try {
      // Utilise nextQuestion(-1) pour forcer le passage √† l'index 0 avec initialisation du timer
      await this.quizService.nextQuestion(-1);
      console.log('[INFO] First question started via HTTP API');
    } catch (error) {
      console.error('Erreur lors du d√©marrage de la premi√®re question:', error);
    }
  }

  startTimer() {
    this.stopTimer();
    this.syncTimerWithServer();
  }

  private async checkAndSyncTimer() {
    try {
      const gameState = await this.quizService.getGameState();

      if (gameState?.questionStartTime) {
        // Le serveur a d√©j√† un questionStartTime, synchroniser
        console.log('üïê Question d√©j√† d√©marr√©e c√¥t√© serveur, synchronisation...');
        this.syncTimerWithServer();
      } else {
        // Pas de questionStartTime c√¥t√© serveur, ne pas d√©marrer le timer
        console.log('‚è∏Ô∏è Pas de timer c√¥t√© serveur, service centralis√© g√®re l\'√©tat');
        // Le service centralis√© g√®re l'√©tat par d√©faut
      }
    } catch (error) {
      console.warn('Erreur v√©rification timer serveur, service centralis√© prend le relais:', error);
      // Le service centralis√© g√®re l'√©tat par d√©faut en cas d'erreur
    }
  }

  private async syncTimerWithServer() {
    try {
      console.log('üïê [PRESENTATION] Synchronisation timer centralis√©e (auto-d√©marrage)');

      // S'abonner aux mises √† jour du timer centralis√© (d√©marrage automatique)
      if (this.timerSub) this.timerSub.unsubscribe();

      this.timerSub = this.timerService.getCountdown().subscribe(timerState => {
        const countdown = timerState.countdownToStart || 0;

        if (countdown > 0) {
          // Mode countdown avant d√©marrage
          this.timerValue = countdown;
          this.timerMax = countdown;
          console.log(`‚è≥ [PRESENTATION] Countdown: Question d√©marre dans ${countdown}s`);
        } else {
          // Mode timer normal
          this.timerValue = timerState.timeRemaining;
          this.timerMax = timerState.timerMax;
          console.log(`üïê [PRESENTATION] Timer: ${timerState.timeRemaining}s/${timerState.timerMax}s, active: ${timerState.isActive}`);

          if (timerState.timeRemaining <= 0 && timerState.isActive === false) {
            this.showResult();
          }
        }
      });

      // Le service centralis√© g√®re la synchronisation initiale automatiquement
      console.log('üïê [PRESENTATION] Service centralis√© actif, synchronisation automatique');

    } catch (error) {
      console.warn('Erreur synchronisation timer, fallback au service centralis√©:', error);
      // Fallback: utiliser le service centralis√© avec d√©marrage simple
      this.timerService.start(20);
    }
  }

  // DEPRECATED: Ancienne m√©thode remplac√©e par le service timer centralis√©
  private startTimerNormal_DEPRECATED(duration: number = 20) {
    console.warn('‚ö†Ô∏è startTimerNormal_DEPRECATED appel√©e - utiliser le service centralis√© √† la place');
    // Ne plus utiliser cette m√©thode, utiliser timerService.startServerSync() √† la place
    this.timerService.start(duration);
  }

  stopTimer() {
    if (this.timerSub) this.timerSub.unsubscribe();
    this.timerService.stopServerSync(); // Arr√™ter la synchronisation centralis√©e
  }

  showResult() {
    // DEBUG : log √©tat avant passage √† l'√©tape r√©sultat
    // Reset image states IMMEDIATELY to prevent any flash
    this.imageLoaded = false;
    this.resultImageLoaded = false;
    // Force immediate UI update to hide images instantly
    this.cdr.detectChanges();

    // On force la mise √† jour des donn√©es avant d'afficher le r√©sultat
    const previousQuestion = this.currentQuestion;
    this.currentQuestion = this.quizService.getCurrentQuestion(this.currentIndex);

    // answersCount est toujours √† jour via l'abonnement (voir ngOnInit)
    if (this.currentQuestion && this.answersCount && Array.isArray(this.answersCount)) {
      this.totalGood = this.answersCount[this.currentQuestion.correctIndex] || 0;
      this.totalAnswers = this.answersCount.reduce((a, b) => a + b, 0);
      this.totalBad = this.totalAnswers - this.totalGood;
    } else {
      this.totalGood = 0;
      this.totalAnswers = 0;
      this.totalBad = 0;
    }
    // Passage √† l'√©tape r√©sultat avec d√©lai pour laisser le flux RxJS se mettre √† jour
    setTimeout(() => {
      this.quizService.setStep('result');
      this.step = 'result'; // Synchronisation imm√©diate pour le template
      this.refresh(); // Correction : forcer la mise √† jour des donn√©es juste apr√®s le changement d'√©tape
      this.cdr.markForCheck();
      // Log apr√®s le changement d'√©tape
      console.log('[DEBUG][RESULT] step:', this.step, 'currentQuestion:', this.currentQuestion, 'answersCount:', this.answersCount);
    }, 120);
  }

  async nextQuestion() {
    // Incr√©mente l'index et passe √† la question suivante via l'API
    try {
      console.log('[PRESENTATION] Next question via HTTP API, current index:', this.currentIndex);

      // Hide images immediately - most aggressive approach
      this.hideImages = true;
      this.imageLoaded = false;
      this.resultImageLoaded = false;

      // Reset timer immediately to sync with image change
      this.timerValue = 0;
      this.stopTimer();

      // Force immediate UI update to hide images instantly and show empty timer
      this.cdr.detectChanges();

      // Petit d√©lai pour laisser l'interface se mettre √† jour
      await new Promise(resolve => setTimeout(resolve, 50));

      // Reset timer to full immediately for visual sync
      this.timerValue = 20;
      this.timerMax = 20;
      this.cdr.detectChanges();

      // CORRECTION: Un seul appel qui g√®re tout (index + step + timer)
      await this.quizService.nextQuestion(this.currentIndex);
      console.log('[PRESENTATION] Question suivante appel√©e, nouvel index:', this.currentIndex + 1);
    } catch (error) {
      console.error('[PRESENTATION] Erreur lors du passage √† la question suivante:', error);
    }
  }

  endGame() {
    this.quizService.setStep('end');
  }

  
  // R√©initialisation compl√®te du quiz (√©tape, participants, index, r√©ponses)
  async resetQuiz() {
    try {
      await this.quizService.resetParticipants();
      await this.quizService.resetAllAnswers();
      await this.quizService.setStep('lobby');
    } catch (error) {
      console.error('[RESET] ‚ùå Erreur lors de la r√©initialisation:', error);
      const errorMsg = error instanceof Error ? error.message : 'Erreur inconnue';
      alert(`Erreur lors de la r√©initialisation du quiz: ${errorMsg}`);
    }
    this.timerValue = 20;
    this.voters = [];

    // Arr√™ter les subscriptions existantes pour √©viter les logs r√©p√©t√©s
    this.subscriptions.forEach(sub => sub.unsubscribe());
    this.subscriptions = [];

    this.refresh();
  }

  // M√©thodes de gestion des images pour √©viter le flash
  onImageLoaded() {
    this.imageLoaded = true;
  }

  onImageError() {
    this.imageLoaded = false;
    console.warn('Erreur de chargement de l\'image:', this.currentQuestion?.imageUrl);
  }

  onResultImageLoaded() {
    this.resultImageLoaded = true;
  }

  onResultImageError() {
    this.resultImageLoaded = false;
    console.warn('Erreur de chargement de l\'image r√©sultat:', this.currentQuestion?.imageUrlResult);
  }

  // TrackBy function pour forcer la recr√©ation des √©l√©ments d'image
  trackByQuestionId(index: number, question: any): any {
    return question?.id || index;
  }

  // ===== M√âTHODES POUR LA PHOTO DE GROUPE =====

  async startCamera(): Promise<void> {
    try {
      // Calculer la r√©solution optimale bas√©e sur l'√©cran
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const aspectRatio = screenWidth / screenHeight;

      // Demander une r√©solution adapt√©e √† l'√©cran
      let videoConstraints: MediaTrackConstraints = {
        facingMode: 'user' // Cam√©ra frontale par d√©faut
      };

      // Adapter la r√©solution demand√©e √† l'√©cran
      if (aspectRatio > 1.5) {
        // √âcran large (16:9 ou plus)
        videoConstraints.width = { ideal: Math.min(1920, screenWidth * 0.9) };
        videoConstraints.height = { ideal: Math.min(1080, screenHeight * 0.9) };
      } else {
        // √âcran plus carr√©
        videoConstraints.width = { ideal: Math.min(1280, screenWidth * 0.9) };
        videoConstraints.height = { ideal: Math.min(720, screenHeight * 0.9) };
      }

      console.log('üìπ Demande de r√©solution cam√©ra:', videoConstraints);

      this.cameraStream = await navigator.mediaDevices.getUserMedia({
        video: videoConstraints,
        audio: false
      });

      this.cameraActive = true;
      this.cameraReady = false;
      this.showCameraModal = true;

      // Attendre que le DOM soit mis √† jour
      setTimeout(() => {
        const videoElement = document.getElementById('cameraVideo') as HTMLVideoElement;
        if (videoElement && this.cameraStream) {
          console.log('üìπ Configuration de l\'√©l√©ment vid√©o...');
          console.log('VideoElement trouv√©:', !!videoElement);
          console.log('CameraStream disponible:', !!this.cameraStream);

          // Forcer l'affichage de la vid√©o
          videoElement.style.display = 'block';
          videoElement.style.opacity = '1';
          videoElement.style.visibility = 'visible';
          videoElement.style.background = 'blue'; // Pour voir si l'√©l√©ment est visible

          videoElement.srcObject = this.cameraStream;

          // Attendre que les m√©tadonn√©es de la vid√©o soient charg√©es
          videoElement.onloadedmetadata = () => {
            console.log(`üìπ M√©tadonn√©es charg√©es: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
            console.log('üìπ ReadyState:', videoElement.readyState);
            console.log('üìπ Style computed:', window.getComputedStyle(videoElement).display);

            // Ajuster le container pour maintenir le ratio
            const container = videoElement.closest('.camera-container') as HTMLElement;
            if (container) {
              const ratio = videoElement.videoHeight / videoElement.videoWidth;
              container.style.aspectRatio = `${videoElement.videoWidth} / ${videoElement.videoHeight}`;
              console.log('üìπ Container aspect ratio d√©fini:', container.style.aspectRatio);
            }
          };

          // S'assurer que la vid√©o est bien en cours de lecture
          videoElement.oncanplay = () => {
            console.log('üìπ Vid√©o pr√™te pour la capture (canplay)');
            console.log('üìπ Video playing:', !videoElement.paused && !videoElement.ended && videoElement.readyState > 2);
            this.cameraReady = true;
          };

          videoElement.onloadeddata = () => {
            console.log('üìπ Donn√©es vid√©o charg√©es (loadeddata)');
            // Test si le stream est bien connect√©
            if (videoElement.srcObject === this.cameraStream) {
              console.log('‚úÖ Stream correctement assign√© √† la vid√©o');
            } else {
              console.error('‚ùå Stream non assign√© correctement');
              // R√©essayer d'assigner le stream
              videoElement.srcObject = this.cameraStream;
            }
          };

          videoElement.onplaying = () => {
            console.log('üìπ Vid√©o en cours de lecture (playing)');
          };

          videoElement.play().then(() => {
            console.log('üìπ Lecture vid√©o d√©marr√©e avec succ√®s');
            // Double v√©rification apr√®s 1 seconde
            setTimeout(() => {
              if (videoElement.readyState >= 2 && videoElement.videoWidth > 0) {
                this.cameraReady = true;
                console.log('üìπ Cam√©ra confirm√©e pr√™te');
                console.log('üìπ √âtat final - Paused:', videoElement.paused, 'Ended:', videoElement.ended, 'ReadyState:', videoElement.readyState);
              }
            }, 1000);
          }).catch(err => {
            console.error('‚ùå Erreur de lecture vid√©o:', err);
          });
        } else {
          console.error('‚ùå √âl√©ment vid√©o ou stream introuvable');
          console.log('VideoElement:', !!videoElement);
          console.log('CameraStream:', !!this.cameraStream);
        }
      }, 100);

      console.log('‚úÖ Cam√©ra d√©marr√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur d\'acc√®s √† la cam√©ra:', error);
      alert('Impossible d\'acc√©der √† la cam√©ra. V√©rifiez les permissions du navigateur.');
    }
  }

  async takeGroupPhoto(): Promise<void> {
    try {
      const videoElement = document.getElementById('cameraVideo') as HTMLVideoElement;

      if (!videoElement || !this.cameraStream) {
        console.error('√âl√©ments cam√©ra introuvables');
        return;
      }

      // V√©rifier que la vid√©o est bien en cours de lecture
      if (videoElement.readyState < 2) {
        console.error('Vid√©o pas encore pr√™te, readyState:', videoElement.readyState);
        alert('La cam√©ra n\'est pas encore pr√™te. Veuillez attendre quelques secondes et r√©essayer.');
        return;
      }

      // V√©rifier les dimensions de la vid√©o
      const videoWidth = videoElement.videoWidth;
      const videoHeight = videoElement.videoHeight;

      console.log(`üìπ Dimensions vid√©o: ${videoWidth}x${videoHeight}`);

      if (videoWidth === 0 || videoHeight === 0) {
        console.error('Dimensions vid√©o invalides');
        alert('Erreur: dimensions de la vid√©o invalides. Veuillez relancer la cam√©ra.');
        return;
      }

      // Cr√©er le canvas avec les bonnes dimensions
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        console.error('Impossible de cr√©er le contexte 2D');
        return;
      }

      // D√©finir les dimensions du canvas
      canvas.width = videoWidth;
      canvas.height = videoHeight;

      console.log(`üé® Canvas cr√©√©: ${canvas.width}x${canvas.height}`);

      // Capturer l'image de la vid√©o
      ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

      // V√©rifier que quelque chose a √©t√© captur√© (pixel test)
      const imageData = ctx.getImageData(0, 0, Math.min(10, canvas.width), Math.min(10, canvas.height));
      const hasContent = Array.from(imageData.data).some(value => value !== 0);

      if (!hasContent) {
        console.error('‚ö†Ô∏è Canvas semble vide, tentative avec d√©lai...');
        // Attendre un peu et r√©essayer
        await new Promise(resolve => setTimeout(resolve, 500));
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      }

      // Ajouter l'overlay "Promotion 2025"
      this.addPromotionOverlay(ctx, canvas.width, canvas.height);

      // T√©l√©charger l'image
      const link = document.createElement('a');
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0];
      link.download = `quiz-promotion-2025-${timestamp}.jpg`;

      // Utiliser une qualit√© plus √©lev√©e pour une meilleure image
      link.href = canvas.toDataURL('image/jpeg', 0.95);

      // D√©boguer: afficher la taille du dataURL
      console.log(`üì∏ Taille de l'image g√©n√©r√©e: ${link.href.length} caract√®res`);

      link.click();

      this.photoTaken = true;
      console.log('‚úÖ Photo de groupe prise avec succ√®s !');

      // Fermer la cam√©ra apr√®s 2 secondes
      setTimeout(() => {
        this.stopCamera();
      }, 2000);

    } catch (error) {
      console.error('‚ùå Erreur lors de la prise de photo:', error);
      alert('Erreur lors de la capture de la photo. Veuillez r√©essayer.');
    }
  }

  private addPromotionOverlay(ctx: CanvasRenderingContext2D, width: number, height: number): void {
    // Fond semi-transparent pour le texte
    ctx.fillStyle = 'rgba(35, 37, 38, 0.8)';
    ctx.fillRect(0, height - 100, width, 100);

    // Texte principal "Quiz Promotion 2025"
    ctx.fillStyle = '#f6d365';
    ctx.font = 'bold 32px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('üèÜ Quiz Promotion 2025', width / 2, height - 60);

    // Date
    const now = new Date();
    ctx.font = '18px Arial, sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(now.toLocaleDateString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }), width / 2, height - 25);

    // D√©coration coins
    ctx.fillStyle = '#DAE72A';
    ctx.font = '24px Arial, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('üåü', 20, height - 40);
    ctx.textAlign = 'right';
    ctx.fillText('üåü', width - 20, height - 40);
  }

  stopCamera(): void {
    if (this.cameraStream) {
      // Arr√™ter tous les tracks de la cam√©ra
      this.cameraStream.getTracks().forEach(track => {
        track.stop();
      });
      this.cameraStream = null;
    }

    this.cameraActive = false;
    this.cameraReady = false;
    this.showCameraModal = false;
    this.photoTaken = false;
    console.log('‚úÖ Cam√©ra ferm√©e');
  }

  getCurrentDate(): string {
    return new Date().toLocaleDateString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }

  // ===== FIN M√âTHODES PHOTO DE GROUPE =====

  // M√©thode de capture graphique du leaderboard final
  async captureLeaderboard(): Promise<void> {
    try {
      // S√©lectionner un √©l√©ment plus large incluant le titre
      const element = document.querySelector('.container-question');
      if (!element) {
        console.error('√âl√©ment container-question introuvable pour la capture');
        return;
      }

      // Configuration html2canvas pour un rendu optimal
      const canvas = await html2canvas(element as HTMLElement, {
        backgroundColor: '#F1F1F1',
        scale: 2, // Haute r√©solution
        useCORS: true,
        allowTaint: false,
        width: (element as HTMLElement).offsetWidth,
        height: (element as HTMLElement).offsetHeight,
        scrollX: 0,
        scrollY: 0,
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        ignoreElements: (element) => {
          // Ignorer les boutons dans la capture
          return element.classList?.contains('step-final-buttons') || false;
        }
      });

      // Cr√©er un contexte pour ajouter des informations suppl√©mentaires
      const finalCanvas = document.createElement('canvas');
      const ctx = finalCanvas.getContext('2d');

      if (!ctx) return;

      // Dimensions du canvas final avec espace pour les m√©tadonn√©es
      const padding = 40;
      const headerHeight = 60;
      const footerHeight = 40;
      finalCanvas.width = canvas.width + (padding * 2);
      finalCanvas.height = canvas.height + headerHeight + footerHeight + (padding * 2);

      // Fond du canvas final
      ctx.fillStyle = '#F1F1F1';
      ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

      // Header avec titre
      ctx.fillStyle = '#232526';
      ctx.font = 'bold 28px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('üèÜ Quiz Application - Final Results', finalCanvas.width / 2, 35);

      // Ligne de s√©paration
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, headerHeight - 10);
      ctx.lineTo(finalCanvas.width - padding, headerHeight - 10);
      ctx.stroke();

      // Dessiner le leaderboard captur√©
      ctx.drawImage(canvas, padding, headerHeight + padding);

      // Footer avec date et heure
      const now = new Date();
      ctx.font = '14px Arial, sans-serif';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'center';
      ctx.fillText(`Generated on ${now.toLocaleString('fr-FR')}`, finalCanvas.width / 2, finalCanvas.height - 15);

      // T√©l√©charger l'image
      const link = document.createElement('a');
      const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T')[0];
      link.download = `quiz-final-results-${timestamp}.png`;
      link.href = finalCanvas.toDataURL('image/png', 0.95);
      link.click();

      console.log('‚úÖ Capture du leaderboard r√©ussie !');
    } catch (error) {
      console.error('‚ùå Erreur lors de la capture:', error);
    }
  }

  // M√©thodes de gestion admin
  extendSession(): void {
    this.adminAuthService.extendSession();
  }

  logout(): void {
    if (confirm('√ätes-vous s√ªr de vouloir vous d√©connecter ?')) {
      this.adminAuthService.logout();
      this.router.navigate(['/admin-login']);
    }
  }

  getRemainingTime(): string {
    return this.adminAuthService.getFormattedRemainingTime();
  }

  // M√©thodes de restauration
  async onRestoreGame(): Promise<void> {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      await new Promise(resolve => setTimeout(resolve, this.minModalDisplayTime - elapsedTime));
    }

    try {
      console.log('üîÑ Tentative de restauration de la partie...');

      const restored = await this.quizService.restoreGameState();
      if (restored) {
        this.showRestoreDialog = false;

        // Synchroniser l'√©tat local avec l'√©tat restaur√©
        this.participants = this.quizService.participants;

        // R√©cup√©rer l'√©tape actuelle du serveur
        try {
          const gameState = await this.quizService.getGameState();
          this.step = gameState?.step || 'lobby';

          // Si on est dans une question, synchroniser le timer
          if (this.step === 'question') {
            console.log('üïê Restauration pendant une question, synchronisation du timer');
            await this.syncTimerWithServer();
          }

        } catch (error) {
          console.warn('Erreur lors de la r√©cup√©ration de l\'√©tape, utilisation de lobby par d√©faut');
          this.step = 'lobby';
        }

        console.log('‚úÖ Partie restaur√©e avec succ√®s !');

      } else {
        console.error('‚ùå Impossible de restaurer la partie');
        this.onStartNewGame();
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la restauration:', error);
      this.onStartNewGame();
    }
  }

  onStartNewGame(): void {
    if (!this.buttonsEnabled) return;

    // Attendre le temps minimum d'affichage du modal
    const elapsedTime = Date.now() - this.modalStartTime;
    if (elapsedTime < this.minModalDisplayTime) {
      setTimeout(() => {
        this.actuallyStartNewGame();
      }, this.minModalDisplayTime - elapsedTime);
    } else {
      this.actuallyStartNewGame();
    }
  }

  private actuallyStartNewGame(): void {
    console.log('üÜï D√©marrage d\'une nouvelle partie');
    this.showRestoreDialog = false;

    // Effacer la sauvegarde pr√©c√©dente
    this.quizService.clearSavedGameState();

    // Initialiser une nouvelle partie
    this.initializeNewGame();
  }

  // M√©thode pour afficher le nom des participants pour le d√©bogage
  getParticipantNames(): string {
    if (!this.participants || this.participants.length === 0) return "Aucun";
    return this.participants.map(p => p.name).join(', ');
  }


  // M√©thode pour v√©rifier directement les participants aupr√®s du serveur
  async checkParticipantsDirectly(): Promise<void> {
    console.log('[DEBUG] V√©rification directe des participants aupr√®s du serveur...');
    try {
      const response = await fetch('http://localhost:3000/api/participants');
      const data = await response.json();
      
      if (Array.isArray(data)) {
        console.log(`[DEBUG] Participants r√©cup√©r√©s directement: ${data.length}`);
        
        if (data.length > 0) {
          // Afficher les informations d√©taill√©es sur chaque participant
          console.log('[DEBUG] Liste des participants:');
          data.forEach((p, idx) => {
            console.log(`[DEBUG] ${idx+1}. ${p.name} (ID: ${p.id})`);
          });
          
          // V√©rifier si certains participants sont absents de la liste locale
          const localIds = this.participants.map(p => String(p.id));
          const serverIds = data.map(p => String(p.id));
          
          const missingLocally = data.filter(p => !localIds.includes(String(p.id)));
          if (missingLocally.length > 0) {
            console.warn(`[DEBUG] ‚ö†Ô∏è ${missingLocally.length} participants sur le serveur mais absents localement:`, 
              missingLocally.map(p => p.name).join(', '));
          }
          
          const missingOnServer = this.participants.filter(p => !serverIds.includes(String(p.id)));
          if (missingOnServer.length > 0) {
            console.warn(`[DEBUG] ‚ö†Ô∏è ${missingOnServer.length} participants locaux mais absents du serveur:`, 
              missingOnServer.map(p => p.name).join(', '));
          }
          
          // Mettre √† jour la liste locale avec les donn√©es du serveur
          this.participants = data;
          console.log('[DEBUG] ‚úÖ Participants mis √† jour:', this.participants.length);
          this.cdr.detectChanges();
        } else {
          console.warn('[DEBUG] ‚ö†Ô∏è Aucun participant trouv√© sur le serveur');
        }
      } else {
        console.error('[DEBUG] ‚ùå Format de r√©ponse invalide (pas un tableau)');
      }
    } catch (error) {
      console.error('[DEBUG] ‚ùå Erreur lors de la v√©rification directe des participants:', error);
    }
  }


  /**
   * R√©initialise uniquement les participants via l'API
   * Cette m√©thode est utilis√©e par restartGame() et d'autres fonctions
   */
  public async resetParticipants() {
    console.log('[RESET] Suppression des participants via API...');
    await this.quizService.resetParticipants();
    
    // Vider la liste locale imm√©diatement
    this.participants = [];
    this.cdr.detectChanges(); // Force l'UI √† mettre √† jour
    
    console.log('[RESET] Participants supprim√©s et interface mise √† jour');
  }


  /**
   * R√©initialisation compl√®te du quiz (√©tape, participants, index, r√©ponses)
   * Cette m√©thode garantit que tous les joueurs sont bien supprim√©s partout
   */
  async restartGame() {
    if (!confirm('√ätes-vous s√ªr de vouloir r√©initialiser compl√®tement le quiz ? Cette action supprimera tous les participants et toutes les r√©ponses.')) {
      return;
    }

    console.log('[RESET] D√©but de la r√©initialisation du quiz');

    try {
      // √âtape 1: Supprimer tous les participants
      console.log('[RESET] 1. Suppression des participants...');
      await this.quizService.resetParticipants();
      
      // Vider la liste locale imm√©diatement pour l'UI
      this.participants = [];
      this.leaderboard = [];
      this.cdr.detectChanges(); // Force l'UI √† mettre √† jour imm√©diatement
      
      console.log('[RESET] 1. ‚úÖ Participants supprim√©s');

      // √âtape 2: R√©initialiser toutes les r√©ponses
      console.log('[RESET] 2. Reset des r√©ponses...');
      await this.quizService.resetAllAnswers();
      console.log('[RESET] 2. ‚úÖ R√©ponses supprim√©es');

      // √âtape 3: Forcer le passage √† l'√©tape "lobby"
      console.log('[RESET] 3. Passage forc√© √† l\'√©tape lobby...');
      // Double appel pour s'assurer de la propagation WebSocket
      await this.quizService.setStep('lobby');
      // Petit d√©lai pour laisser le temps au WebSocket de traiter
      await new Promise(resolve => setTimeout(resolve, 500));
      await this.quizService.setStep('lobby'); // Second appel pour forcer
      console.log('[RESET] 3. ‚úÖ √âtape lobby d√©finie et rediffus√©e');
      
      // √âtape 4: V√©rification de la suppression compl√®te des participants
      console.log('[RESET] 4. V√©rification des participants sur le serveur...');
      const participants = await this.quizService.fetchParticipantsFromServer();
      
      // Double v√©rification que la liste est bien vide
      if (participants && participants.length > 0) {
        console.error('[RESET] ‚ö†Ô∏è ATTENTION: Le serveur a retourn√© des participants apr√®s reset:', participants);
        // Forcer la liste vide localement pour √™tre s√ªr
        this.participants = [];
        // Nouvelle tentative de reset c√¥t√© serveur
        await this.quizService.resetParticipants();
      } else {
        console.log('[RESET] 4. ‚úÖ Confirmation de liste vide:', participants?.length || 0);
        this.participants = [];
      }
      
      this.cdr.detectChanges();

      console.log('[INFO] Quiz reset via HTTP API');
      alert('Quiz r√©initialis√©. Tous les participants et r√©ponses ont √©t√© supprim√©s.');

      // √âtape 5: R√©initialisation de l'√©tat local du composant
      console.log('[RESET] 5. R√©initialisation locale de l\'√©tat...');
      this.step = 'lobby';
      this.currentIndex = 0;
      this.currentQuestion = null;
      this.answersCount = [];
      this.leaderboard = [];
      this.imageLoaded = false; // Reset image state
      this.resultImageLoaded = false; // Reset result image state
      
      // V√©rification finale apr√®s un d√©lai pour s'assurer que tout est vide
      setTimeout(async () => {
        const checkParticipants = await this.quizService.fetchParticipantsFromServer();
        console.log('[RESET] V√©rification finale participants:', checkParticipants?.length || 0);
        if (checkParticipants && checkParticipants.length > 0) {
          console.warn('[RESET] ‚ö†Ô∏è Des participants existent encore apr√®s reset! Nouvelle tentative...');
          await this.quizService.resetParticipants();
          this.participants = [];
          this.cdr.detectChanges();
        }
      }, 2000);
      
      console.log('[RESET] 5. ‚úÖ √âtat local r√©initialis√©');
    } catch (error) {
      console.error('[RESET] ‚ùå Erreur lors de la r√©initialisation:', error);
      alert('Une erreur est survenue lors de la r√©initialisation. Veuillez r√©essayer.');
    }
  }
}
